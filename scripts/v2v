#!/usr/bin/perl 
# $Revision: 1.37 $
# vi: formatoptions=croq:expandtab:sts=4:sw=4 :
#
# AUTHORS :     Roland SEUHS <rolandATwertkarten.net>
#               Dominique CARON <domiATlpm.univ-montp2.fr> 
#		Tom ROTH <tomATtomroth.de>
#		Luis Mondesi <lemsx1AThotmail_dot_com>
# GPL LICENSE 
# http://www.gnu.org/licenses/gpl.html
#
# ChangeLog: http://www.lpm.univ-montp2.fr/~domi/V2divx/changelog.html
#
# BUGS:
#   * transcode doesn't work with kernel 2.6.0 (not yet)
#   * unable to encode Logo + 2 Audio channels in Cluster mode (not yet)
#
# TODO:
#   SEE TODO FILE
#   
#  HACKING: Warning
#   Du to TELECINE $deintl MUST Stay the first transcode filter ( -J opt)
#   Added new filter with the form
#   $new_filter=" thefilter=options,";  ( with the comma at the end )

use POSIX;
use Env qw(HOME);
use FileHandle;
use File::Temp qw/ tempfile  /;     # Perl 5.6.1: 
                                    # used to get secured temp file
STDOUT->autoflush(1);

# get options. Most of the V2divxrc options (if not all)
# should be overriden by this command line ones

use Getopt::Long;
Getopt::Long::Configure('bundling');

# get options
# declare empty variables
# flags
my ($HELP,$VERSION,$RUNCLUST,$SRTSUBRIP,$OKCLUSTER) = 0;
# others
my ($SVIDEO_FORMAT,$ROOT_DIRECTORY) = "";

GetOptions(
    # flags
    'h|help'        =>  \$HELP,
    'v|version'     =>  \$VERSION,
    'runclust'      =>  \$RUNCLUST,
    'srtsubrip'     =>  \$SRTSUBRIP,
    'tv'            =>  \$TVREC,
    'd|debug'       =>  \$DEBUG,
    'i|info'        =>  \$INFO,
    'c|with-cluster'   =>  \$OKCLUSTER,
    # strings
    'D|directory=s'             => \$ROOT_DIRECTORY,
    's|source-video-format=s'   => \$SVIDEO_FORMAT,
    'x|x_video=s'               => \$DIVX,
    'F|x_video_opts=s'          => \$DIVX_OPT,
    'V|video_player=s'          => \$XINE,
    'A|avi_player=s'            => \$AVIPLAY,
    'I|image_viewer=s'          => \$XV,
    'C|cluster_config=s'        => \$CLUSTER_CONFIG,
    'r|remote_cmd=s'            => \$RMCMD,
    'n|nice=s'                  => \$nice,
    'L|logo=s'                 => \$LOGO, 
    'l|lang|language=s'         => \$LANGUAGE, 
    'S|sub_title_opts=s'      => \$EXTSUB ,
    # numbers
    'a|default_audio_channel=i'   => \$DEF_AUDIOCHANNEL 
);
    # reset DIVX_OPT if DIVX is pass as parameter and not DIVX_OPT
    $DIVX_OPT="" if ( defined $DIVX && ! defined $DIVX_OPT);
    # set debugging or info mode
    $DEBUG=STDOUT if ( $DEBUG );
    $INFO=STDOUT if ( $INFO);

$userconfigfile="$HOME/.V2divxrc";

$userconfig="
#		This file is use by V2divx to read your default parameters
#
#		The nice level of transcode ( nice -$nice transcode ....)
\$nice=10;
#			Choose your preferred encoder
\$DIVX=ffmpeg;	       # ffmpeg is the Transcode include divx encoder but you can use
#  divx4,divx5,xvid,xvid2,xvid3 .... if you have it#			Add your encoder specifics options

#			Add your encoder specifics options
\$DIVX_OPT=-F mpeg4 #  for example '-F mpeg4' for divx ffmpeg output 

#		Image Viewer
\$XV=display;   # you may use \'xv\' 

#     		Video Player
\$XINE=xine; # You may modify your Movie Viewer (xine for example) 

# 		DivX Player
\$AVIPLAY=xine; # You may modify your DivX4 Viewer (mplayer) 
#

#		Cluster config if you intend to use cluster mode
\$CLUSTER_CONFIG=/path/to/.V2divxrc-cluster;  # YOU MUST MODIFY THIS LINE !!!

#               Xterm command (default is 'xterm \%s -e'). \%s is a 
#               series of arguments that will be passed before the
#               execution code '-e' or '-x' according to the given
#               terminal. Xterm requires that all arguments come before
#               -e for instance.
#               You can also set it to things like: gnome-terminal -x, 
#               konsole -x, screen -d -m, etc...
\$XTERM=xterm \%s -e ;

# 		remote command if you intend to use cluster mode
\$RMCMD=ssh; 			# change this to rsh if you need

# 	Location of your Image Logo 
# if this file exist the logo will be automatically include when 
# running V2divx /path/to/vob file_size (alias Quick mode ) 
\$LOGO=/where/is/your/logo.img;

#      Your Default Logo Position (1=TopLeft,2=TopRight,3=BotLeft,4=BotRight,5=Center)
\$POSLOGO=4;

#      Default starting time logo ( in second after the movie beginning )
\$STARTLOGO=2;

#     Default Logo Duration ( in second )
\$TIMELOGO=25;

#		Your preferred Language (fr,en,de...) for audio channel encoding 
#			( USE V2divx rip to enable this !!!) 
\$LANGUAGE=en;

# If for some reason V2divx is unable to determine the audio channel 
# for your LANGUAGE, put here the audio channel number
# ( generally 0 is your language, 1 is english, 2 is another ...)
\$DEF_AUDIOCHANNEL=0;   
# to trace V2divx put this to STDOUT or /dev/null for none
\$DEBUG=STDOUT;
# to know what system command are run by V2divx put this to STDOUT
\$INFO=STDOUT;

# EXT SUBTITLE FILTER 5 LAST OPTIONS (here we just use 3) ...See the docs 8-(
\$EXTSUB=0:0:255;
";

############# SOME VARIABLES ###################
$release="2.2.4 (C) 2002-2003 Dominique Caron";
$last_sec=0;
$v2d="[V2divx]";
$deb_sec=0;
$keyframes = 250;
$audiosample_length = 1000;
$PGMFINDCLIP=pgmfindclip; # New tool of transcode
$DVDTITLE=dvdtitle;
$RED="\033[1;31m";
$GREEN="\033[0;32m";
$NORM="\033[0;39m";
$MAJOR=0;
$MINOR=6;
$VFORMAT="PAL";   # Default video format

#  Functions Declarations
sub mydie;
sub makelogo;
sub audioformat;
sub videoformat;
sub create_nav;
sub create_extract;
sub calculate_nbrframe;
sub calculate_bitrate;
sub aviencode;
sub a_bitrate;
sub get_params;
sub make_sample;
sub cluster;
sub merge;
sub twoac;
sub finish;
sub ask_filesize;
sub ripdvd;
sub readconf;
sub ask_logo;
sub zooming;
sub findclip;
sub interlaced;
sub get_audio_channel;
sub readuserconf;
sub printinfo;
sub chk_wdir;
sub smily;
sub audiorescale;
sub subtitle;
sub format_date;
sub sec_to_hour;
sub pinfo;
sub perror;
sub pwarn;
sub tv_recorder;

system("clear");

    # Domi Caron
    # Luis, Is'nt it better to start time just
    # when the encoding start ?
my $start_time = time;
my $f_start_time = format_date($start_time);
pinfo("Start Time: $f_start_time \n");

# Read or create the user configuration file
# we kept .vob2divxrc for backward compatibility
if ( -e $HOME."/.vob2divxrc" )  
{
    rename($HOME."/.vob2divxrc",$userconfigfile);
}

if ( -e $userconfigfile )
{   
    readuserconf;
} else {
    open ( USERCONF,"> $userconfigfile");
    print USERCONF $userconfig;
    close USERCONF;
    readuserconf;
}

#    Find the transcode release 
$tr_vers=`transcode -v 2>&1 | awk '{print \$2}'| sed s/^v// `;
@Vers = split /\./,$tr_vers;
if (  $Vers[0] < $MAJOR  || ( $Vers[0] == $MAJOR && $Vers[1] < $MINOR ) )
{	 
    pwarn("This V2divx perl script does not support".
    " your transcode release\n Please upgrade to the latest".
    " transcode release (0.6.11 at least)\n");
    exit(1);
}

# Test if the $DIVX module is OK
$module=`transcode -c 2-3 -i /dev/zero -y $DIVX,null $DIVX_OPT 2>&1 | grep 'critical'`;  # Bug (transcode)
if ( $module ne "" )
{      
    pwarn(" According to your \$DIVX variable, ".
    "you want to encode with $DIVX libraries\n But it ".
    " seems that $DIVX libraries are not installed on ".
    " your system\n Please install it or change ".
    "the \$DIVX variable in your $userconfigfile\n");
    exit(0);
}
$clust_percent="--cluster_percentage --a52_dolby_off ";
pinfo("$v2d\t Transcode detected release:\t\t   | $Vers[0].$Vers[1].$Vers[2]\n");

if  ( ! $RUNCLUST )
{
    foreach $pgm ( $XV, $XINE, $AVIPLAY ) 
    {
        my(@pgm)=split / /,$pgm;
        if ( system("which $pgm[0] > /dev/null 2>&1 ") )
        { 
            pwarn(" $pgm is not installed on this System :-( \n Modify your $userconfigfile to reach your configuration (DVD player, DivX player, Image viewer....) \n"); 
            exit (0);
        }
    }
}

$PGMFINDCLIP=OK if (! system("which $PGMFINDCLIP >/dev/null 2>&1 "));

$SUBRIP=system("which subtitle2pgm >/dev/null 2>&1 ");
$SUBRIP=system("which pgm2txt >/dev/null 2>&1 ") if ( $SUBRIP == 0 );
$SUBRIP=system("which srttool >/dev/null 2>&1 ") if ( $SUBRIP == 0 );
$SUBRIP=system("which gocr >/dev/null 2>&1 ") if ( $SUBRIP == 0 ); 
$SUBRIP="OK" if ( $SUBRIP == 0 );

$DVDTITLE="" if ( system("which $DVDTITLE >/dev/null 2>&1 ")!=0);

$urldvdtitle=$GREEN."\t V2divx is unable to find dvdtitle in your PATH.\n\t Code Sources of dvdtitle are available at : \n\t http://www.lpm.univ-montp2.fr/~domi/V2divx/dvdtitle.tgz\n ".$NORM."\n";

$warnclust = 
$RED."***********  WARNING ABOUT CLUSTER MODE *************".$NORM."
If you want to use a cluster :
a) The /path/to/vobs directory must be NFS mounted on each node
    and have the same name.
b) You must have rsh or ssh permission on each node,
( modify your $userconfigfile to select rsh or ssh ).
c) You need to have a $RED${CLUSTER_CONFIG}$NORM file (change this value in your $userconfigfile) on the node you run V2divx on.
This file must contain all the nodenames of your cluster:the percentage of frames to encode by each node.
Syntax of this file:
# This is a Comment
# nodename:percentage
asterix:25   #  Duron 333 Mhz
obelix:5  # 486 66Mhz
vercingetorix:70 # Thunderbird 1.2 Ghz
${RED}Of course the total of percentage frames to encode MUST be 100
\n\n".$NORM;

$usage =
$RED."            *****  Warning  *****$NORM
Please note that you are only allowed to use this program according to fair-use laws which vary from country to country. You are not allowed to redistribute 
copyrighted material. Also note that you have to use this software at your own risk.

------------------------------------------------------
You may want first rip vob files from a DVD :
then use:

% V2divx /path/to/vobs rip
(where /path/to/vobs is the directory where vob files will be ripped)
It is recommended to rip your DVD with V2divx because it save precious informations about the movie to encode. (probe.rip)
---------------------------------------------------

NB: $RED transcode will encode your movie in $DIVX format , to change this,
edit your $userconfigfile and change the \$DIVX variable. $NORM

There are 2 ways of using this program to encode your vob file(s):

1: Easy\n
-----------
% V2divx /path/to/vobs 700
(where 700 is the desired filesize in Megabytes, and /path/to/vobs the directory where are the unencrypted vob files)
This mode (alias Quick mode) take all parameters in your $userconfigfile  which has been created the first time you have run V2divx. 
Take a look in it please.

2: Better\n
----------
% V2divx /path/to/vobs config 
This will ask all what it need to make the movie you want ;-)
( /path/to/vobs is the directory where are the unencrypted vob files).

3) Recording TV\n
----------
% V2divx /path/to/moviefiles --tv
(where /path/to/moviefiles is a directory where V2divx will keep the temporaries movies files.

------------\n
You can interrupt the program anytime. To continue encoding, just run the script
without parameters in the same directory.\n$RED\t You MUST NOT run V2divx from the /path/to/vobs directory.\n$NORM
V2divx v$release
\n\n
";
$readme=" 
$RED V2divx $NORM is a perl script which make a lot of work for you to
rip/encode your Videofiles or TVrecord in a AVI-Divx file with the fabulous Transcode. 

\t\t What does $RED V2divx $NORM do ?

1) rip your DVD to vob files.
2) detect titles ( and then the main title ) of a DVD.
3) detect the DVD volume identification if you install dvdtitle.
4) detect if the DVD title is a multi-angle video stream (and rip only one).
5) detect if the video frames are interlaced.
6) detect all audio channels (and their languages) in the input video files.
7) detect the input format of all audio channels (mp3,dts,ac3,lpcm,mpeg2ext).
8) supports to encode two audio channels in avi files.
9) detect suggested volume rescale.
10) is able to add subtitles (on stream or in an srt subfile).
11) detect the aspect ratio and then calculate the best output image size,
Note: this does NOT give you the best aspect ratio, but the best image quality.
V2divx use the Bits per Pixel value :
BpP=bitrate*1000/(fps * height * width)
V2divx uses BpP=0.18 without letterboxes, BpP is recalculated depending on letterboxes size.
The smaller the video bitrate, the smaller will be the image size (your avi player will resize it to full screen).
The final aspect ratio rarely is much different from the original aspect ratio (which pratically never respects the motion picture aspect ratio.)
12) detect if deinterlacing is necessary (and detect if transcode was compiled with the MPlayer pp lib and/or mpeg tools)
13) detect if the slow Zooming transcode option (-Z) is necessary or not.
14) is able to encode on a cluster (even multiple sequence unit video streams)
15) is able to prepend a Logo to the DivX (even in cluster mode since release 1.0.2) .
16) remove (if you want) the end and begin credits (to reduce space and leave it to the movie itself).
17) is able to record TV (if you've installed NVrec)
18) And finally guide you from your Video file to your DivX file.

That's all Folk's ;)... 
All you need is perl, transcode, xv (or ImageMagick), a video file viewer (Mplayer, Xine, playdv etc...), a divx (MPEG-4) viewer (MPlayer or aviplay etc...) and optionally (but recommended) dvdtitle, pgmfindclip and the srttools (see the contrib transcode source directory).

You will find the latest $RED V2divx $NORM Release at:
$GREEN
http://www.lpm.univ-montp2.fr/~domi/V2divx
$NORM
where you will find also the dvdtitle source code.

Enter '$0 --help|-h ' to have a small help
";


# You may Modify the Next value but take care
# (see the transcode man pages - about Bits per Pixel)
# it's used to estimate the image size of the encoded clip
$bpp=0.18;   # This value =  bitrate x 1000 / ( fps x height x width ) 

############# FUNCTIONS #########################

sub tv_recorder
{
    print $DEBUG "---> Enter TV Recorder\n";
    my($heures,$minutes,$w)="";
    $FPS=25;
    $TVREC=1;
    $CLUSTER="NO";
    # record the TV .
    if ( ! -e "tmp/V2divx.conf")
    {
        print " How many minutes do you want to record ? ";
        $runtime=<STDIN>;
        chomp($runtime);
        print " What is your desired movie file size (in Mo)? ";
        $filesize=<STDIN>;
        chomp($filesize);
        a_bitrate;
        print " Which Quality do you want:\n\t1) High Quality - Which need a VERY big and fast harddisk (~240Mo/mn) and is very long to encode (9fps on a 1.2Ghz CPU)\n";
        print "\t2) Normal Quality - Which is fast and need only 2 * final movie size\n\t (default 2)?:";
        $qual=<STDIN>;
        chomp($qual);
        $qual=2 if ( $qual eq "" );
        if ( $qual==1 )
        {
            my $diskspace=240 * $runtime/ 1024 ;
            pwarn("\t\t *** WARNING *** \n You need average $diskspace Go to record this Movie\n");
        }
        open (CONF,">>tmp/V2divx.conf");
        print CONF "#TVREC:$TVREC#DO NOT MODIFY THIS LINE\n";
        print CONF "#VOBPATH:$VOBPATH# DO NOT MODIFY THIS LINE\n";
        print CONF "#runtime:$runtime\n";
        print CONF "#filesize:$filesize\n";
        print CONF "#qual:$qual\n";
        print CONF "#CLUSTER:$CLUSTER\n";
        close(CONF);
    }
    $deintl="yuvdenoise" if ( $qual==1 );
    $heures=int($runtime/60);
    $minutes=$runtime- $heures * 60;
#    $bitrate=int((136.53 * $filesize)/$runtime- $audio_bitrate);
    $bitrate=int((139.5 * $filesize)/$runtime - $audio_bitrate);
    $NXaxis=512;
    $NXaxis=384 if ( $qual==1);
    $NYaxis=384;
    $NYaxis=288 if ( $qual==1);
    $runtime=60*$runtime;
    $audio_size=$audio_bitrate*$runtime/(8*1024);
    $fbpp=1000*$bitrate/($NXaxis*$NYaxis*$FPS);

    $nbr_frames=$FPS*$runtime;
    $dvdtitle="movie";
    print " Your TV channel MUST be selected, you can interrupt recording with\n";
    printinfo;
    if ( $rep ne "y" && $rep ne "Y" ) 
    {   unlink("tmp/V2divx.conf");
        rmdir("tmp");
        exit(0)
    }
    if ( $qual==1 )
    {
        $sys=sprintf("transcode -c 0-%02d:%02d:00  -V -i /dev/video0 -x nvrec=\"-N 32\",null  -y yuv4mpeg,null -g ${NXaxis}x${NYaxis} -u 100 -o $VOBPATH/only_video.mpeg -m $VOBPATH/only_audio.avi -p /dev/dsp -H0 -f %d ",$heures,$minutes,$FPS);
    }else{
        $sys=sprintf("transcode -c 0-%02d:%02d:00  -V -i /dev/video0 -x nvrec=\"-N 32 -deint bob -ddint \",null  -J dilyuvmmx -y $DIVX,null $DIVX_OPT -g ${NXaxis}x${NYaxis} -w %d,250 -u 100 -o $VOBPATH/only_video.avi -m $VOBPATH/only_audio.avi -p /dev/dsp -H0",$heures,$minutes,$bitrate);
    }

    print $DEBUG "+ $sys\n";
    if ( ! -e "tmp/Record_done")
    {
        unlink("tmp/pass1_done") if ( -e "tmp/pass1_done");
        unlink("tmp/pass2_done") if ( -e "tmp/pass2_done");
        system("$sys"); 
        system("touch tmp/Record_done");
    }else{
        pwarn("\t Recording already done, remove \"tmp/Record_done\" to record again \n");
        sleep(2);
    }
        
    if ( $qual==1 )
    {
        $sys=sprintf("transcode -i $VOBPATH/only_video.mpeg -p $VOBPATH/only_audio.avi -x yuv4mpeg,mp3 -R 1,tmp/Video.log  -y $DIVX $DIVX_OPT -w %d,250 -o /dev/null -u 100 -J $deintl,32detect=force_mode=3,dnr",$bitrate);
        pinfo("\t\tEncoding  Pass One \n");
        print $DEBUG "+ $sys\n";
        if ( -e "tmp/pass1_done" )
        {   pwarn("\tHigh Quality Pass One already encoded, remove \"tmp/pass1_done\" to reencode \n");
        }else{
            unlink("tmp/pass2_done") if ( -e "tmp/pass2_done");
            system("nice -$nice $sys")==0 or mydie "Problem to Encode Pass 1";
            system ("touch tmp/pass1_done");
        }
        $sys=sprintf("transcode -i $VOBPATH/only_video.mpeg -p $VOBPATH/only_audio.avi -b $audio_bitrate,0 -x yuv4mpeg,mp3 -R 2,tmp/Video.log  -y $DIVX $DIVX_OPT -w %d,250 -o movie.avi -u 100 -J dnr,yuvdenoise,32detect=force_mode=3",$bitrate);
        pinfo("\t\t Pass Two \n");
        print $DEBUG "+ $sys\n";
    }else{
        $sys="transcode -i $VOBPATH/only_video.avi -p $VOBPATH/only_audio.avi -P 1 -b $audio_bitrate,0 -o movie.avi -y raw";
        pinfo("\t\t Merging Audio+Video\n");
        print $DEBUG "+ $sys\n";
    }
    if ( -e "tmp/pass2_done" )
    {   pwarn(" Pass Two already encoded, remove \"tmp/pass2_done\" to reencode \n");
    }else{
        system("nice -$nice $sys")==0 or mydie "Problem to merge audio and Video Pass 2";
        system ("touch tmp/pass2_done");
    }
    print $DEBUG "<--- TV Recorder\n";
    exit(0);
}
    

sub format_date 
{
    # returns a nicely formatted string:
    # @param 0 unixtimestamp
    # @param 1 "hours"
    # if no second parameter is given, returns a date string 
    # formatted in ISO-8660
    # if second parameter "hours" is given, it converts
    # the number of seconds passed to hours
    if ( exists ($_[1]) && $_[1] eq "hours" ) {
        # we care about hours
        return sprintf("%.2f",$_[0] / ( 60 * 60 )); # 3600 number of seconds in an hour
    }

    # take a UNIX timestamp and returns a nicely formatted string
    my ($sec,$min,$hour,$mday,$mon,$year) = localtime(shift);
    my $ADATE=sprintf("%04d-%02d-%02d %02d:%02d:%02d",($year+=1900),$mon,$mday,$hour,$min,$sec);
    return $ADATE;
} # end format date

sub sec_to_hour {
    # convert seconds into a string HH:MM:SS
    # @param 0 number of seconds
    my $seconds = shift;

    my ($days,$hours,$minutes);

    if ( $seconds > 86400) 
    {
        print STDERR "ERROR: sec_to_hour: This value is higher than a day\n";
        return "00:00:00";
    }

    # Here we don't care about the number of days in $seconds
    # however, I included this for those who care about that value
    # - Luis Mondesi
    #$days = int($seconds / (24 * 60 * 60));
    #$seconds -= ($days * 24 * 60 * 60);

    $hours = int($seconds / ( 60 * 60 ));
    $seconds -= ($hours * 60 * 60);

    $minutes = int($seconds / 60);
    $seconds -= $minutes * 60;

    return sprintf("%02d:%02d:%02d",$hours,$minutes,$seconds);
} # end sec_to_hour

sub srt_subrip
{
    print $DEBUG "---> Enter srt_subrip\n";
    print $DEBUG "subtitle channel=@_[0], subtitle language@_[1]\n";
    if ( ! -e "$HOME/.V2divx_db" )
    {
        umask(000); # resets current umask values. Luis Mondesi 
        mkdir ("$HOME/.V2divx_db",01777);
        pinfo("$v2d\t PGM2txt database created:\t\t   | ${RED}${HOME}/.V2divx_db\n");
    }
    if ( ! -e "db")
    {
        system("ln -s $HOME/.V2divx_db db");
        pinfo("$v2d\t PGM2txt database ${RED}db${GREEN} linked to \$HOME/.V2divx_db\n");
    } 
    if ( ! -f "tmp/srtpgm_done")
    {
        unlink "tmp/srtpgm2txt_done" if (-f "tmp/srtpgm2txt_done");
        @def_grey=('255,255,0,255','255,255,255,0','255,0,255,255','0,255,255,255');
        my $i=0;
        $rep="NO";
        pinfo("$v2d\t In this Terminal we will prepare your subtitle file\n");
        print " As the grey levels of subtitles varied, I first make only one subtitle image.\n Subtitle image is good when the background is WHITE and the foreground is BLACK.\n Take a look on this subtitle image\n Press Enter ->";
        $junk=<STDIN>;
        while ( $rep ne 'Y' && $rep ne 'y' && $rep ne 'O' && $rep ne 'o' )
        {
            mydie "Problems with your subtitle image grey level .. Sorry\n Read the transcode man pages and change the \$EXTSUB variable in your ~/.V2divxrc \n" if ( $i == 4 );
            $sys="cat $VOBPATH/* | tcextract -x ps1 -t vob -a 0x2@_[0] | subtitle2pgm -c @def_grey[$i] -e 00:00:00,1 -C 15 -o tmp/${dvdtitle}_test";
            system("$sys")==0 or mydie ("Failed to execute:\n $sys");
            system("$XV tmp/${dvdtitle}_test0001.pgm");
            print " Was this subtitle image good (y|N)? ";
            $rep=<STDIN>;
            chomp($rep);
            $i++;
        }
        system("rm tmp/${dvdtitle}_test*");
        $i--;
        my $pid = fork();
        mydie "couldn't fork" unless defined $pid;
        if ($pid)
        {
            pinfo("$v2d\t Making subtitle images. This may take a while...\n");
            # try different positions for zero  when output is not optimal (default  255,255,0,255)
            $sys="cat $VOBPATH/* | tcextract -x ps1 -t vob -a 0x2@_[0] | subtitle2pgm -c @def_grey[$i] -C 15 -o tmp/$dvdtitle";
            print $INFO $sys."\n";
            system("nice -$nice $sys") == 0  or ( system("touch tmp/srtpgm.finish")==0 and mydie "Failed to execute : $sys" ) ;
            system("touch tmp/srtpgm.finish");
            wait;
            system("touch tmp/srtpgm_done");
        } else {
            smily(srtpgm);
        }
    } else {
        pwarn("$v2d\t Subtitle2pgm already done, remove tmp/srtpgm_done, to remake it\n");
    }
    if ( ! -f "tmp/srtpgm2txt_done")
    {
        unlink "$dvdtitle.srt" if ( -f "$dvdtitle.srt");
        # run pgm2txt without ocr using a db file (db file can be reused for other rips )
        system ("pgm2txt -v -f @_[1] -d  tmp/$dvdtitle");
        system("/bin/rm tmp/$dvdtitle*.pgm");
        system("touch tmp/srtpgm2txt_done");
    } else {
        pwarn("$v2d\t Pgm2txt already done, remove tmp/srtpgm2txt_done  to remake it\n");
    }
    if ( ! -f "$dvdtitle.srt")
    {
        system ("srttool -s -v -i tmp/$dvdtitle.srtx -o $dvdtitle.srt");
        system("/bin/rm tmp/$dvdtitle*.pgm.txt");
    } else {
        pwarn("$v2d\t $dvdtitle.srt already done, remove it to remake it\n");
    }	
    #    maybe spell checking should be optional
    $ilang="-d french" if ( @_[1] eq 'fr');
    $ilang="-d german" if ( @_[1] eq 'de');
    $ilang="-d spanish" if ( @_[1] eq 'es');
    $ilang="-d english" if ( @_[1] eq 'en');
    system ("ispell $ilang  $dvdtitle.srt");
    print $DEBUG "<--- srt_subrip\n";
}

sub mydie
{
    print $RED.@_[0]."\n".$NORM;
    if ( ! $RUNCLUST  && ! $SRTSUBRIP )
    {
        system("mv tmp/dvdtitle $VOBPATH/dvdtitle") if ( -e "tmp/dvdtitle" );
        system("mv tmp/probe.rip $VOBPATH/probe.rip") if ( -e "tmp/probe.rip" );
    } else { 
        system("/bin/rm tmp/$dvdtitle*.pgm tmp/$dvdtitle.srtx 2> /dev/null");
        sleep(3);
    }
    unlink("tmp/PB");
    exit(1);
}
use sigtrap qw(handler mydie normal-signals error-signals) ;

sub makelogo
{
    print $DEBUG "---> Enter makelogo\n";
    if ( $addlogo > 300 )
    {
        pwarn("Unable to create your Logo in cluster Mode\n");
        sleep(5);
        return(1);
    }
    pinfo("$v2d\t Making Logo\n");
    $fparams="$params -c $from_frames-$synclogo";
#    $fparams =$fparams." -M 2 --psu_mode --nav_seek tmp/file.nav --no_split " if ( $VFORMAT eq "NTSC" );
    $fparams =$fparams." -M 2 " if ( $VFORMAT eq "NTSC" );
#     $fparams =$fparams." -M 0 -f 23.976 --psu_mode --nav_seek tmp/file.nav --no_split " if ( $deintl =~ m,ivtc,);
     $fparams =$fparams." -M 0 -f 23.976 " if ( $deintl =~ m,ivtc,);
    $add_logo="logo=file=$LOGO:posdef=$poslogo:rgbswap=$RGBSWAP:range=$start_frames_logo-$end_frames_logo,";
    $filter=$deint.$add_logo.$sub_title.",hqdn3d";
    audiorescale;
    if ( ! -e "tmp/logopass1.done")
    {
        unlink("tmp/logopass2.done") if ( -e "tmp/logopass2.done");
        my $pid = fork();
        mydie "couldn't fork" unless defined $pid;
        if ($pid)
        {
            pinfo("$v2d\t Pass One ...");
            $sys = "transcode -q 0 -i $VOBPATH $fparams -w $bitrate,$keyframes -J $filter -y $DIVX,null $DIVX_OPT $VID_OPT -R 1,tmp/$DIVX.logo.log -o /dev/null";
            print $INFO $sys."\n";
            system("nice -$nice $sys") == 0  or ( system("touch tmp/logop1.finish")==0 and mydie "Failed to execute : $sys" ) ;
            system("touch tmp/logop1.finish");
            wait;
            system("touch tmp/logopass1.done");
        } else {
            smily(logop1);
        }
    } else {	 
        pwarn("\tLogo pass 1 already done,".
        " remove tmp/logopass1.done to reencode it\n");
    }
    if ( ! -e "tmp/logopass2.done")
    {
        $filter=$filter.",dnr,normalize"; 
        my $pid = fork();
        mydie "couldn't fork" unless defined $pid;
        if ($pid)
        {
            pinfo("$v2d\t Pass Two ...");
            $sys = "transcode -q 0 -i $VOBPATH $fparams  -w $bitrate,$keyframes -s $audio_rescale -J $filter -b $audio_bitrate,0 -y $DIVX $DIVX_OPT $VID_OPT -R 2,tmp/$DIVX.logo.log -o tmp/Logo.avi";
            print $INFO $sys."\n";
            system("nice -$nice $sys")== 0  or ( system("touch tmp/wait.finish")==0 and mydie "Failed to execute: $sys");
            system("touch tmp/logop2.finish");
            wait;
            system("touch tmp/logopass2.done");
        } else { 
            smily(logop2);
        }
    } else { 	
        pwarn("\tLogo pass 2 already done,".
        " remove tmp/logopass2.done to reencode it\n");
    }
    rename("tmp/2-${dvdtitle}_sync.avi","tmp/withoutlogo.avi");
    $sys = "avimerge -i tmp/Logo.avi tmp/withoutlogo.avi -o tmp/2-${dvdtitle}_sync.avi";
    print $INFO $sys."\n";
    system("nice -$nice $sys")==0 or mydie "Failed to execute: $sys";;
    print $DEBUG "<--- makelogo\n";
}

sub audiorescale
{     
    print $DEBUG "---> Enter audiorescale\n";
    if ( $CLUSTER ne "NO" )
    {	
        create_extract if ( ! -e "tmp/extract.text" || ! -e "tmp/extract-ok" ) ;
        $info=`cat tmp/extract.text`;
        ( $info =~ m,suggested volume rescale=(\d+.*\d+),) or mydie "Unable to find Suggested volume rescal in tmp/extract.text";
        if ( $1  > 1)
        {
            $audio_rescale = $1;
        } else {
            $audio_rescale = 1;
        }
    } else {
        if ( ! -e "tmp/astat" )
        {
            pwarn("Unable to find a suggested Volume rescale !\n 1 is use for -s parameter\n");
            $audio_rescale=1;
            sleep(2);
        } else {
            $audio_rescale=`cat tmp/astat`;
            chomp($audio_rescale);
        }
    }
    print $DEBUG "<--- audiorescale\n";
}  # END audiorescale

# This function just display a clock to wait
sub smily
{
    unlink("tmp/$_[0].finish");
    @t=('|','/','-','\\');
    my $i=0;
    while(! -e "tmp/$_[0].finish")
    {
        $i=0 if ($i >3);
        print $t[$i]."\b";
        sleep(1); 
        $i++;
    }
    sleep(1);
    unlink("tmp/$_[0].finish");
    exit(0);
}

sub chk_wdir
{	
    print $DEBUG "---> Enter chk_wdir\n";
    # We check if user is not working in /path/to/vobs
    chomp($VOBPATH);
    $wdir=`pwd`;
    #chdir($VOBPATH); #unecessary
    ( $VOBPATH ne $wdir ) 
        or mydie "You MUST NOT run V2divx from the ".
    " /path/to/vob directory ...\nPlease cd to another directory";
    chomp($wdir);
    #chdir($wdir);
    print $DEBUG "+ Working directory ".`pwd`;

    # Move probe.rip and dvdtitle
    system ("mv $VOBPATH/dvdtitle tmp/dvdtitle") if ( -f "$VOBPATH/dvdtitle");
    system ("mv $VOBPATH/probe.rip tmp/probe.rip") if ( -f "$VOBPATH/probe.rip");
    # Verify that there is no alien files in VOBPATH 
    # AND GET the Video Input Format
    # TODO
    # Luis Mondesi <lemsx1AT_NO_SPAM_hotmail.com> 
    # 2003-12-14 17:35 EST 
    # We should also check for valid filetypes extensions.
    # the most common ones at least.
    # Or, remove a given set of files from here... like any
    # text file. Perhaps use the "file" UNIX utility to
    # determine if a file is text data or whatever
    # and exclude it from this @files array?
    
    opendir(VOB,$VOBPATH);
    my(@files)=grep {! /^\./ & -f "$VOBPATH/$_"} readdir(VOB);
    closedir(VOB);
    # sort in dictionary order...
    my $da;
    my $db;
    @files = sort { 
        ($da = lc $a) =~ s/[\W_]+//g;
        ($db = lc $b) =~ s/[\W_]+//g;
        $da cmp $db;
    } @files;
    #@files=sort @files;
    my $i=0;
    foreach $file (@files)
    {   
        videoformat("$VOBPATH/$file");
        if ( $i == 0 )
        {
            $tmp=$in_video_codec;
            pinfo("$v2d\t Video Input Format:\t\t\t   | $in_video_codec\n");
            mydie "$VOBPATH/$file has not a valid video format" if ( $in_video_codec eq null );
        }
        mydie "$VOBPATH/$file is not a valid file. All $VOBPATH files (except dvdtitle and/or probe.rip) MUST have the same format" if ( $tmp ne $in_video_codec );
        $i++;
        print $INFO "File $i: $file\n";
    }
    mydie "Only ONE AVI, DV  or QT file is allowed to transcode at a time.\n Please merge those $i avi (dv or qt ) files\n"  if (( $in_video_magic eq divx || 
    $in_video_magic eq mov || 
    $in_video_magic eq mpeg2  || 
    $in_video_magic eq 'dv'  ) && 
    $i > 1 );
    $sample = $files[floor($i / 2)];
    print $DEBUG "Sample : $sample\n";
    $lastvob = $files[$i-1];
    print $DEBUG "Last file : $lastvob\n";
    ( -f "$VOBPATH/$sample" and -f "$VOBPATH/$lastvob" ) or 
    mydie "Unable to find samples files in \"$VOBPATH\" ".
    "(files MUST be have the same Video format)";

    # Vrfy probe.rip
    if ( -e "tmp/probe.rip")
    {
        # We need to verify if user has not remove some file(s) since the rip
        print $INFO "\t Number of vob files:$i\n";
        closedir(VOB);
        open (PROBE,"<tmp/probe.rip");
        while(<PROBE>)
        {
            if ( $_=~ m,Number of vob files:(\d+),)
            {
                if ( "$i" ne "$1" )
                {
                    # If user has remove some files we cannot use probe.rip anymore
                    pwarn("Number of vob files in probe.rip is not exact, V2divx will create extract.txt \n");
                    system ("touch tmp/probe.rip-BAD");
                }
                $flag=0; last;
            } else {
                $flag=1;
            }
        }
        close(PROBE);
        pwarn("Oups...no number of Vob files in the probe.rip file!\n") if ( $flag eq 1 );
    }

    if ( ! defined($dvdtitle) && -e "tmp/dvdtitle")
    {
        $dvdtitle=`cat tmp/dvdtitle`;
        chomp($dvdtitle);
    }
    print $DEBUG "<--- chk_wdir\n";
} # End Check Working directories

sub get_audio_channel
{	
    print $DEBUG "---> Enter get_audio_channel\n";	
    $number_of_ac=0;
    my($i)=0;
    if ( -e "tmp/probe.rip" )
    {
        open (RIP,"<tmp/probe.rip");
        while(<RIP>)
        {       
            chomp;
            if ( $_ =~ m,(?:ac3|mpeg2ext|lpcm|dts|mp3) ([^\s]+) ,)
            {
                pinfo("$v2d\t Language of audio stream $i:\t\t   | $1\n") if ( ! defined(@_[0])); 
                $findaudio_channel=$i if ( $1 eq $LANGUAGE && ! defined($findaudio_channel));
                $i++;
            }
        }
    }
    # get_audio_channel has been call by printinfo ;-)
    return(0) if ( defined($_[0]) ); 
    if ( $in_video_magic eq 'mov' )
    {
        $probe=`tcprobe -i $VOBPATH/$sample 2>&1 | grep 'audio track:'` or mydie "Problem when running \'tcprobe -i $VOBPATH/$sample\'";
    } else {
        $probe=`tcprobe -i $VOBPATH 2>&1 | grep 'audio track:'` or mydie "Problem when running \'tcprobe -i $VOBPATH\'";
    }
    # If this is so complicated this is because ... YES sometime audio channel are not in order !!
    @line=split /\n/,$probe;
    $tmp=$line[0];
    # set flag to false to test for audio
    $flag_ac_detected = "0"; # this flag is just for this
    # following loop and nothing else

    foreach $tmp ( @line )
    {	
        if ( $tmp =~ m,-a (\d) \[, )
        {
            #print $DEBUG "-a DIGIT found \n ";
            $achannels[$number_of_ac]=$1;
            print $INFO "\t + Channel: $achannels[$number_of_ac]\n" ;
            $number_of_ac++;
            $tmp=$line[$number_of_ac];
            $flag_ac_detected = 1;

        } elsif ( $tmp =~ m,no audio track,) {	 
            $number_of_ac++;
            $tmp=$line[$number_of_ac];
            $number_of_ac--;
            #			 mydie " There is NO audio track in your clip,\n Sorry, at this moment, I'm unable to work on it ....";
            $NOAUDIO=1;
            pwarn("$v2d\t No audio channels in this Clip\n");
            print $DEBUG "  <--- get_audio_channel\n";

            return(0);
        } elsif ( $flag_ac_detected eq 0) { 
            mydie "Unable to get audio track info ?\n";
        }
    }
    pinfo("$v2d\t Number of audio channels detected:\t   | $number_of_ac\n");
    $number_of_ac--;
    if ( defined($findaudio_channel))
    {
        $audio_channel=$findaudio_channel;
        pinfo("$v2d\t Audio channel for $RED$LANGUAGE$GREEN language:\t\t   | $audio_channel\n\t (You may modify your \$LANGUAGE variable in your $userconfigfile)\n");
    } else {
        pinfo("$v2d\t Unable to find your Language ($LANGUAGE) in:\t   | tmp/probe.rip \n$v2d\t Default audio channel is set to ");
        if ( $DEF_AUDIOCHANNEL <= @achannels[$number_of_ac])
        { 
            $audio_channel = $DEF_AUDIOCHANNEL;
            print ":\t   | ".$RED;
        } else {
            $audio_channel=0;
            print ":\t   | ".$RED;
        }	
        print $audio_channel."\n".$NORM;
    }
    print $DEBUG "<--- get_audio_channel\n";
} # end get_audio_channel

sub readuserconf
{
    if ( -e $HOME."/.V2divxrc" ) {
        open (USERCONF,"<$HOME/.V2divxrc");
    } else {
        open (USERCONF,"<$HOME/.vob2divxrc");
    }
    while (<USERCONF>)
    {
        chomp;
        # On an idea of tom roth <tom@tomroth.de>
        s[/\*.*\*/][];      #  /* comment */
        s[//.*][];          #  // comment
        s/#.*//;            #  # comment
        s/^\s+//;           #  whitespace before stuff
        s/\s+$//;           #  whitespace after stuff
        next unless length; #  If our line is empty, we ignore it
        s/^\$//;
        s/\;$//;
        s/^\s+//;           #  whitespace before value 
        s/\s+$//;           #  whitespace after value
        s/["']+//g;         # remove all quotes
        my ($var_name, $value) = split(/\s*=\s*/, $_);
        print "WARNING : ~/.V2divxrc variable $var_name value not used, set to $$var_name\n".$NORM  if ( defined $$var_name && $var_name ne DEBUG && $var_name ne INFO);
       $$var_name = $value if ( ! defined $$var_name  );
    }
    close (USERCONF);

    $DIVX="ffmpeg" if ( ! defined ($DIVX));
    if ( ! defined ( $DIVX_OPT))
    {    
        $DIVX_OPT="";
        $DIVX_OPT="-F mpeg4" if ( $DIVX eq "ffmpeg");  
        open (USERCONF,">>$userconfigfile");
        print USERCONF "# Add your encoder specifics options \n\$DIVX_OPT=$DIVX_OPT ; #for example '-F mpeg4' for divx ffmpeg output";
        close(USERCONF);
    }
    $XV=xv if ( ! defined ($XV));
    $XINE=xine if ( ! defined ($XINE));
    $AVIPLAY=aviplay if ( ! defined ($AVIPLAY));
    $RMCMD=ssh if ( ! defined ($RMCMD));
    $XTERM="xterm \%s -e" if ( ! defined ($XTERM) ); print $DEBUG "+ using terminal $XTERM\n";
    $POSLOGO=4 if ( ! defined ($POSLOGO));
    $CLUSTER_CONFIG="/see/your/V2divxrc" if ( ! defined ($CLUSTER_CONFIG));
    $TIMELOGO=25 if ( ! defined ($TIMELOGO));
    $LOGO="/see/your/V2divxrc" if ( ! defined ($LOGO));
    $DEF_AUDIOCHANNEL=0 if ( ! defined ($DEF_AUDIOCHANNEL));
    $LANGUAGE=fr  if ( ! defined ($LANGUAGE));
    $STARTLOGO=2 if ( ! defined ($STARTLOGO));
    $nice=10 if ( ! defined ($nice));
    $INFO="STDOUT" if ( ! defined ($INFO));
    $DEBUG="/dev/null" if ( ! defined ($DEBUG));
    if ( ! defined ($EXTSUB))
    {
        open (USERCONF,">>$userconfigfile");
        print USERCONF "# EXT SUBTITLE FILTER 5 LAST OPTIONS (here we just use 3) ...See the docs 8-(\n\$EXTSUB=0:0:255;";
        close(USERCONF);
        $EXTSUB="0:0:255";
    } 

} # END readuserconf

sub printinfo
{	
    system("clear") if ( $DEBUG ne STDOUT && $INFO ne STDOUT );	
    print "\t*********************************************************\n";
    if ( $TVREC )
    {
        print $v2d." A/V:\t${RED}TV Recorder Quality:\t   | ";
        print "High" if ( $qual==1);
        print "Normal"  if ( $qual==2);
        print $NORM."\n";
    }else{
        print $v2d."   V:\tVideo input Format:\t   | $VFORMAT\n";
    }
    print $v2d."   V:\tVideo Output format:\t(1)| $DIVX\n";
    print $v2d."   V:\tVideo Input interlaced:\t   | ";
    if ( defined($deintl) || $params=~ m,-I 3, )
    {
        print $RED."YES\n".$NORM;
        print $v2d."   V:\tDeinterlaced with:\t(2)| ";
        print "MPlayer postproc\n" if ( $deintl =~ m,pp, );
        print "YUVdenoise \n" if ( $deintl =~ m,yuvdenoise,); 
        print "Smartdeinter \n" if ( $deintl =~ m,smartdeinter,); 
        print "ivtc \n" if ( $deintl =~ m,ivtc,); 
        print "-I 3\n" if ($params=~ m,-I 3, )
    } else {
        print "NO\n";
    }

    print $v2d."   V:\tLogo file name:\t\t(1)| $LOGO\n";
    if ( ( $addlogo && $CLUSTER eq "NO" ) || 
        ( $addlogo != 0 && $addlogo <= 300 && $CLUSTER ne NO))
    {
        $start_frames_logo=floor(($deb_sec+$beginlogo)*$FPS);
        $end_frames_logo=floor($addlogo*$FPS+$start_frames_logo);
        $add_logo="logo=file=$LOGO:posdef=$poslogo:rgbswap=$RGBSWAP:range=$start_frames_logo-$end_frames_logo,";
        $endlogo=$beginlogo+$addlogo;
        print  $v2d."   V:\tLogo starting time:\t(2)| $beginlogo s.\n";
        print  $v2d."   V:\tLogo ending time:\t(2)| $endlogo s.\n";
    } else {
        print $v2d."   V:\tLogo inserted:\t\t   | ${RED}NO${NORM}\n";
    }
    get_audio_channel("junk") if (! defined($findaudio_channel));
    print $v2d."   A:\tLanguage Audio channel:\t(1)| $LANGUAGE\n" if (defined($findaudio_channel)) ;
    print $v2d."   C:\tCluster config file:\t(1)| $CLUSTER_CONFIG\n" if ( $CLUSTER ne NO);
    print $v2d."   C:\tCluster remote cmd:\t(1)| $RMCMD\n" if ( $CLUSTER ne NO);
    open (CC,"<$CLUSTER_CONFIG");
    my $i=1;
    while(<CC>)
    {
        if ( $_=~ m/([^\s#]*)#*/)
        {
            print $v2d."   C:\tCluster node $i:\t\t(3)| $1% frames to process\n" if ( $CLUSTER ne NO && $1 ne "" );
            $i++ if ( $CLUSTER ne NO && $1 ne "" );
        }	
    }
    close CC;   
    print $v2d."   V:\tFrames to encode:\t   | $nbr_frames, @ $FPS frames per/sec\n";
    printf($v2d." A/V:\tRuntime to encode:\t   | %d hours:%d minutes:%d sec\n",int($runtime/3600),int($runtime-int($runtime/3600)*3600)/60,$runtime-int($runtime/60)*60);
    if ( ! $TVREC )
    {
        $params =~ m,-a (\d) .*,;
        print $v2d."   A:\tPrimary Audio channel:\t   | $1\n";
        if ( defined($ac2))
        {
            chomp($ac2);
            print $v2d."   A:\tSecundary Audio Channel:(2)| $ac2\n";
        }
    }
    printf($v2d."   A:\tAudio size:\t\t   | %.2f Mb @ (2) $audio_bitrate Kb/s\n",$audio_size);
    $videosize=$bitrate*1000*$runtime/(1024*1024*8);
    printf($v2d."   V:\tEstimated Video Size:\t   | %.2f Mb @ %d Kb/s\n",$videosize,$bitrate);
    $totalsize=$videosize+$audio_size;
    printf($v2d." A/V:\tEstimated Total Size:\t(2)| %.2f Mb\n",$totalsize);
    if ( ! $TVREC )
    {
        print $v2d."   V:\tInput Frame Size:\t   | ${Xaxis}x$Yaxis\n";
        printf($v2d."   V:\tClipped Frame Size:\t   | %dx%d \n",$Xaxis-2*$lr,$Yaxis-2*$tb);
        printf($v2d."   V:\tOriginal aspect ratio:\t   | %.2f:1\n",$aspect_ratio);
    }
    print $v2d."   V:\tOutput Frame Size:\t   | ${NXaxis}x$NYaxis\n";
    printf($v2d."   V:\tFinal aspect ratio:\t   | %.2f:1\n",$NXaxis/$NYaxis);
    printf($v2d."   V:\tAspect ratio error:\t   | %.2f %\n",$AR);
    printf($v2d."   V:\tBits Per Pixel:\t\t   | %.3f\n",$fbpp);
    print $v2d." A/V:\tFinal AVI file name:\t   | $RED$dvdtitle$NORM.avi\n";
    print  $DEBUG $v2d."   T:\tTrcode main parameters:\t(2)| $params\n";
    $subtitle=$sub_title if ( $sub_title =~ m,extsub,); # Bug
    my $filter=$deintl.$add_logo.$subtitle;
    print $DEBUG $v2d."   T:\tOptional Filters:\t(2)| $filter\n";
    print "\n";
    print "(1)This value can be modify in your $userconfigfile\n";
    print "(2)This value can be modify in tmp/V2divx.conf\n";
    print "(3)This value can be modify in your $CLUSTER_CONFIG\n" if ( $CLUSTER ne NO);
    print $RED."\tYou can say \'no\' at this time, modify by hand some parameters \n\t in the tmp/V2divx.conf(BUT TAKE CARE!) \n\t or in your $userconfigfile,\n\t and then rerun V2divx without parameters\n".$NORM;
    print " Ready to encode (y|N)? ";
    $rep=<STDIN>;
    chomp($rep);
    mydie "" if ( $rep ne "y" && $rep ne "Y" );
    my $pid= fork();
    mydie "couldn't fork" unless defined $pid;
    if ( $pid == 0 )
    {
        if ( ! -e "$dvdtitle.srt" && $sub_title =~ m,SRT_(\d+)_(.*),)
        {
            system(sprintf("$XTERM $0 --srtsubrip &",""))==0 or print STDERR "couldn't exec $XTERM $0 --srtsubrip\n";
        }
        exit(0);
    } 
    wait;
    $sub_title="" if ( $sub_title =~ m,SRT_,);
}

sub interlaced
{
    pinfo("$v2d\t Detecting if frames are interlaced:\t   | ");
    my $pid = fork();
    mydie "couldn't fork" unless defined $pid;
    if ($pid)
    { 
        $interlace=`transcode -i "$VOBPATH/$sample" -J 32detect=verbose -c 0-500 2>&1 | grep interlaced`;
        system("touch tmp/intl.finish");
        wait;
    } else {
        smily(intl);
    }
    if ( ! ( $interlace =~  m,interlaced = (yes),))
    {
        ( $interlace =~  m,interlaced = (no),) or mydie "Unable to Detect Interlacing in $VOBPATH/$sample";
        $INTERLACE="no";
        pinfo("NO\n");
    } else {
        $INTERLACE="yes";
        pwarn("YES\n");
    }
}

sub findclip
{
    if ( $PGMFINDCLIP eq OK )
    {
        pinfo("$v2d\t Trying to detect best Clipping:\t   | ");
        opendir(VOB,$VOBPATH);
        my(@files)=grep {! /^\./ & -f "$VOBPATH/$_"}readdir(VOB);
        closedir(VOB);
        my $da;
        my $db;
        @files = sort { 
            ($da = lc $a) =~ s/[\W_]+//g;
            ($db = lc $b) =~ s/[\W_]+//g;
            $da cmp $db;
        } @files;
        #@files=sort @files;
        my $i=0;
        my $pid = fork();
        mydie "couldn't fork" unless defined $pid;
        if ($pid)
        { 	
            foreach $file (@files)
            {	
                $sys="transcode -M 1 -q 0 -z -K -x $in_video_codec,null -i \"$VOBPATH/$file\" -y ppm,null -c 130-135  -o autoclip$i  >/dev/null 2>&1";
                # DO WE REALLY NEED video_magic ?
                # $sys="transcode -M 1 -q 0 -z -K -i\
                # \"$VOBPATH/$file\" -y ppm,null -c 130-135\
                # -o autoclip$i  >/dev/null 2>&1";
                print $DEBUG "$sys\n";
                system ("$sys")==0 or 
                ( system("touch tmp/fndclip.finish && /bin/rm autoclip*.pgm ")==0 and  
                mydie "Unable to encode to ppm file ($VOBPATH/$file)" );
                $i++;
            }
            system("touch tmp/fndclip.finish");
            wait;
        } else {
            smily(fndclip);
        }
        $clip=`pgmfindclip -b 8,8 autoclip*.pgm` or ( system("/bin/rm autoclip*.pgm") and mydie "Problem to run \'pgmfindclip -b 8,8\'\n Your pgmfindclip release is may be too old ...\n");
        chomp($clip);
        @clip=split /,/,$clip;

        # We put the clipping border same size ( the smallest )
        $clip[0]=$clip[2] if ( $clip[2] < $clip[0] ) ;
        $clip[1]=$clip[3] if ( $clip[3] < $clip[1] ) ;
        system("/bin/rm autoclip*.pgm");
        $tb=$clip[0];
        $lr=$clip[1];
        pinfo("-j $tb,$lr\n");
    } else {
        pwarn("$v2d\t pgmfindclip in your PATH:\t\t   | NO\n");
        print $INFO "You may find pgmfindclip at http://www.lallafa.de/bp/pgmfindclip.html\n";
        sleep(2);
        $tb=0;
        $lr=0;
    }
}

# ========= ASK if Cluster is used ============== #
# And initialize the number of stream units if yes
sub ask_clust
{
    my ($rep)='n';
    print $DEBUG "--->  Enter ask_clust\n";
    $CLUSTER="NO";
    open(CONF,">>tmp/V2divx.conf");
    unlink("tmp/cluster.args");
    pinfo("$v2d\t Cluster config file exist:\t\t   |");
    if ( ! -e $CLUSTER_CONFIG )
    {
        pwarn(" NO\n");
    } else {
        pinfo(" Yes\n") if ( -e $CLUSTER_CONFIG );
        if ( ! $OKCLUSTER )
        {
            print " Do you want to use a cluster (y|N)? ";
            $rep=<STDIN>;
            chomp($rep);
        }else{
            $rep='y';
        }
        if ( $rep eq "y" || $rep eq "Y" || $rep eq "o" || $rep eq "0")
        {	
            create_nav ;
            my $stream_units=`tail -1 tmp/file.nav | awk '{print \$1}'`;
            chomp($stream_units);
            if ( $stream_units > 10 ) # Take care there is too much stream units !!
            {
                pwarn("\tThere is too much stream units".
                " in this clip to encode it\n".
                "\tin cluster mode with a good ".
                "video quality\n\tReversing to NO".
                " CLUSTER...\n");
                $stream_units=NO;
                sleep(2);
            }
            # WE need create-extract in CLUSTER Mode to have $audio_rescale :-(
                create_extract if ( $stream_units ne NO && ( ! -e "tmp/extract-ok" || ! -e "tmp/extract.text"));
            # Initialize the $CLUSTER to the number of stream Units or to NO if there
            # is too much Stream Units 
                $CLUSTER=$stream_units;
        }
    }
    print CONF "#CLUSTER:$CLUSTER # YOU CAN REMOVE BUT NOT MODIFY THIS LINE\n";
    close(CONF);
    print $DEBUG "<--- ask_clust\n";
}

# ============= Cluster MODE =================== # 
sub cluster
{ 	
    print $DEBUG "--->  Enter cluster\n";
    # Need to know working directory 
    # and pass it to the cluster nodes (to find tmp/*)
    $wdir=`pwd`;
    chomp($wdir);
    ( -e $CLUSTER_CONFIG ) or mydie $warnclust;

    # Open a secure temporary file in /tmp/ to 
    # rebuild cluster config file
    # which contain ONLY available nodes
   
    # returns a filehandle and filename
    my $s_file = new File::Temp(
                                "UNLINK"    => 0, # do not unlink
                                "TEMPLATE"  => "XXXXXXXXX",
                                "DIR"       => "tmp", # NFS
                                "SUFFIX"    => ".txt"
                            );
    # FIXME
    print $DEBUG "\nfile +++++++> $s_file <----- file\n\n";
    
    # $node_counter is the counter of AVAILABLE nodes
    my $node_counter=`grep -v "^[[:space:]]*#" $CLUSTER_CONFIG | grep -v '^[[:space:]]*$$' | wc -l`;

    if ( $node_counter != 0 )
    {
        # $poweroff is the percentage of frame 
        # that we can't encode on affected nodes 
        # (cause they are unavailable)
        my $poweroff=0;

        # $poweron is the percentage of frame
        # that we can encode on affected nodes
        my $poweron=0;

        $localhost=`hostname`;
        chomp($localhost);

        # TODO use Perl code to read this file:
        #   @allnodes=custom_read_file(); where this function returns a string
        # read the cluster config file
        @allnodes=`grep -v "^[[:space:]]*#" $CLUSTER_CONFIG | grep -v '^[[:space:]]*$$'| awk -F"#" '{print \$1}'`;

        foreach $node  ( @allnodes )	
        {
            # chost[0] is the node name
            # chost[1] is the percent of frames to encode
            @chost=split /:/, $node;
            $rhost=$chost[0];
            if ( $rhost ne "$localhost" )
            {	
                pinfo("$v2d\t Checking node $rhost ...:\t\t \n");
                my $pid = fork();
                mydie "couldn't fork [function: cluster]" unless defined $pid;
                if ($pid)
                {
                    $sys="$RMCMD $rhost 'cd ".$wdir." && ".$0." -v' >/dev/null 2>&1";  
                    print $INFO $sys."\n";
                    $rs=system ("$sys");
                    system("touch tmp/checknode.finish");
                    wait;
                } else {
                    smily(checknode);
                }
                # $rs != 0 means node unreachable 
                # or 'V2divx -v' exit with non 0 status
                # or master working directory does not exist on node
                # so we don't run on it
                if ( $rs != 0 )
                {
                    $node_counter = $node_counter - 1;
                    pwarn("\tNode $rhost unable to run $0 ...\n");
                    $P=$chost[1];
                    chomp($P);
                    $poweroff = $poweroff + $P;
                    pwarn("\tNeed to calculate $poweroff % of frames on other node(s)\n");
                    last if ( $poweroff >= 100 );
                } else {
                    $P=$chost[1];
                    chomp($P);
                    # This node is OK we print it in the good nodes temporary file
                    print $s_file "$rhost:$P\n";
                    $poweron = $poweron + $P;
                }
            } else { 
                # This is the master (localhost) 
                $P=$chost[1];
                chomp($P);
                print $DEBUG "+ Host : ".$chost[0]." , Pow = $P\n";
                print $s_file "$rhost:$P\n";
                $poweron = $poweron + $P;
            }
        }
        # $addpower is the percentage of frames
        # that available nodes need to encode 
        # more than requested
        $addpower = $poweroff / $node_counter;

        # FIXME
        print $DEBUG "\n++++++> Sleeping ... \n";
        sleep(10);
        close($s_file);
    } else {
        # we don't need cluster-mode?
        print $DEBUG "\n+++++> Unlinking file $s_file";
        unlink("$s_file");
    }

    pinfo("$v2d\t Number of available Nodes:\t\t   |$node_counter\n");

    # Now we have number of a available nodes
    # percentages of frames that each nodes
    # need to encode more
    # So we run V2divx on nodes ...
        # FIXME
        print $DEBUG "\n++++++> Sleeping ... \n";
        sleep(10);
    if ( -f "$s_file" )
    {	
        # tabpower is just a table to know when nodes 
        # have finished to encode
        $tabpower="";

        # percentage of frames already encode 
        my $sumpow=0;

        my  $max=0;	
        $i=0;
        @allnodes=`cat $s_file`;
        unlink("$s_file"); 

        foreach $node (@allnodes )     
        { 
            @chost=split /:/, $node; 
            $rhost=$chost[0];
            if ( $sumpow < 100 )
            {	
                # we add the percentage of frames to encode more
                $pow=$chost[1] + $addpower;
                # percentage of frames which will be encoded
                $max=$sumpow + $pow;
                # is this is > %100 just encode to reach 100% .
                $pow = 100 - $sumpow if ( $max > 100 );

                open(CLUSTERARGS,">tmp/cluster.args");
                print CLUSTERARGS "$sumpow,$pow\n";
                close(CLUSTERARGS);
                pinfo("$v2d\t Encoding on node $rhost:\t   | -W $sumpow,$pow\n");
                $this_arg=""; # reset arguments
                $this_cmd=""; # reset command string
                if ( $rhost ne "$localhost" &&  $rhost ne "localhost" ) 
                { 	
                    # Luis Mondesi 
                    # -n remote_host is the name of the window for
                    # xterm. or it will be left blank for other terminals
                    # note that $XTERM contains the %s string placeholder
                    # you might want to add more arguments according
                    # to which XTERM the user wants... gnome-terminal,
                    # konsole, screen, etc... 
                    $this_arg="-n $rhost" if $XTERM =~ /xterm/i;
                    $this_cmd=sprintf("$XTERM $RMCMD $rhost $0 --runclust $wdir &",$this_arg);
                    print $DEBUG "+ executing $this_cmd\n";
                    system ( $this_cmd );
                } else {
                    $this_arg="-n $rhost" if $XTERM =~ /xterm/i;
                    $this_cmd=sprintf("$XTERM $0 --runclust $wdir &",$this_arg);
                    #$this_cmd=sprintf("$XTERM ls --runclust $wdir &",$this_arg);
                    print $DEBUG "+ executing $this_cmd\n";
                    system ( $this_cmd );
                }
                $tabpower[$i]=$sumpow;
                $i++;
                $sumpow= $sumpow + $pow;
                # we have to be SURE that V2divx has started on the remote node 
                # before continue ( we wait for 15 secondes max)
                my $j=0;
                while ( ! -e "tmp/node_started" && $j < 15 )
                {
                    sleep(1);
                    $j++;
                }
                perror("V2divx on node $rhost is well started\n");
                unlink("tmp/node_started" );
                mydie("Seems that there is a problem on node $rhost\n $0 has not started correctly\n Unable to continue.\n") if ( $j == 15 );
            }
        }
        # If percentage of frames < 100%
        # We encode the rest on localnode
        if  ( $sumpow <  100 )
        {
            $pow = 100 - $sumpow;
            open(CLUSTERARGS,">tmp/cluster.args");
            print  CLUSTERARGS "$sumpow,$pow\n";
            close(CLUSTERARGS);
            pinfo("$v2d\t Encoding on localnode with:\t\t   | -W $sumpow,$pow to finish\n");
            system ( sprintf("$XTERM $0 --runclust $wdir &","") );
            $tabpower[$i]=$sumpow;
            sleep(3);
        }

        pinfo("$v2d\t Waiting for nodes to finish ....\n");

        foreach $endnode ( @tabpower )
        {
            while ( ! -e "tmp/2-$dvdtitle${endnode}_0.finish" && ! -e "tmp/2-$dvdtitle${endnode}.PB" && ! -e "tmp/1-$dvdtitle${endnode}.PB")
            {
                print "\r|"; 
                sleep(1); 
                print "\r/"; 
                sleep(1); 
                print "\r-"; 
                sleep(1); 
                print "\r\\"; 
                sleep(1);
            }
            pinfo("$v2d\t Node $endnode has finished encoding\n") if ( -e "tmp/2-$dvdtitle${endnode}_0.finish");
            pwarn("\tCritical error on node: $endnode during Pass One\n") if ( -e "tmp/1-$dvdtitle${endnode}.PB");
            pwarn("\tCritical error on node: $endnode during Pass Two \n") if ( -e "tmp/2-$dvdtitle${endnode}.PB");
            $NODE_ERROR=1 if ( -e "tmp/2-$dvdtitle${endnode}.PB" || -e "tmp/1-$dvdtitle${endnode}.PB");
            unlink("tmp/2-$dvdtitle${endnode}.PB");
            unlink("tmp/1-$dvdtitle${endnode}.PB");
        }	
        mydie("\tCould'nt continue, critical error on one or more nodes ...\n") if ( $NODE_ERROR );
        merge;
        twoac;
        finish;
        unlink("tmp/cluster.args");
    } else {
        pwarn("\tNothing to do :-(\n");
    }
    print $DEBUG "<--- cluster\n";
    exit(0);
    # End cluster Sub routine
}


#  ***************** Create Nav File (For cluster) *****************

sub create_nav
{
    return()  if (  -e "tmp/filenav-ok" &&  -e "tmp/file.nav" );
    my $demux=" -M 2" if ( $VFORMAT eq "NTSC" );
    pinfo("$v2d\t Creating File Navigation:\t\t   | tmp/file.nav\n");
    my $pid = fork();
    mydie "couldn't fork [function: create_nav]" unless defined $pid;
    if ($pid)
    {
        # Domi, do we need to use VOB extensions? What if files
        # don't have this extensions -- Luis 2004-01-07 20:28 EST 
        $sys = "cat $VOBPATH/*.[Vv][Oo][Bb] | tcdemux $demux -W > tmp/file.nav";
        print $INFO $sys."\n";
        system ("nice -$nice $sys") == 0  or ( system ("touch tmp/filenav.finish")== 0 and mydie "Unable to create file nav" );
        system("touch tmp/filenav.finish");	
        wait;
        system("touch tmp/filenav-ok");
    } else {
        smily(filenav);
    }
}
#  ****** Create extract info (to calculate bitrate) ****** #

sub create_extract
{
    print $DEBUG "--->  Enter create_extract\n";
    get_audio_channel if ( ! defined($audio_channel));
    $audio_format=audioformat("-a $audio_channel") if ( $NOAUDIO != 1 );	
    a_bitrate if ( ! defined($audio_bitrate));
    $info=`transcode -i $VOBPATH -c 1-2 2> /dev/null` or mydie "Problem when running \'transcode -i $VOBPATH \'";
    $info =~ m,V:\s+encoding\s+fps.*\|\s+(\d+\.\d+),;
    my($FPS)=$1;
    if ( $FPS =~ m,29\.97, )
    {
       print(" Is this Movie a NTSC TELECINE movie (MPlayer is your friend to know that)?[y|N]");
      my $rep=<STDIN>;
        chomp($rep);
        $TELECINE=1 if ( $rep eq "y" || $rep eq "Y" );
    }
    $VFORMAT="NTSC" if ( $FPS =~ m,2[39]\.9, );
#    create_nav if ( $VFORMAT eq "NTSC");

    if ( $NOAUDIO == 1  || $need_time == 1 )  
    {
        # || $in_video_magic eq 'mpeg2'(OK V=mpeg2,A=mp3.mpg)  
        # || $in_video_magic eq 'vdr' )
        pwarn(" A tcextract bug do not allow me to extract correct informations from this  $in_video_magic streams\n") if ( $need_time == 1 );
        pwarn(" As there is no audio channel, V2divx is unable to extract some informations from this Clip\n") if ( $NOAUDIO == 1 ); 
        print " So please, say me how long is this movie (in seconds)?:";
        my $rep=<STDIN>;
        chomp($rep);
        my $frames=floor($rep*$FPS);
        my $audiosize=$audio_bitrate*1000*$rep/(1024*1024*8);
        open(EXTRACT,">tmp/extract.text");
        print EXTRACT "[V2dscan] audio frames=$frames, estimated clip length=$rep seconds
        [V2dscan] V: $frames frames, $rep sec @ $FPS fps
        [V2dscan] A: $audiosize MB @ $audio_bitrate kbps";
        close(EXTRACT);
        system("touch tmp/extract-ok");

    } elsif ( $in_video_magic eq 'mov' ) {
        my $info=`tcprobe -i $VOBPATH/$sample 2>&1` or mydie "Error when running 'tcprobe -i $VOBPATH/$sample'";
        my $frames = $1 if ( $info =~ m, length: (\d+) frames,);
        my $rep = floor($frames/$FPS);
        my $audiosize=$audio_bitrate*1000*$rep/(1024*1024*8);
        print $DEBUG " Frames = $frames , lenght = $rep , audiosize = $audiosize \n";
        open(EXTRACT,">tmp/extract.text");
        print EXTRACT "[V2dscan] audio frames=$frames, estimated clip length=$rep seconds
        [V2dscan] V: $frames frames, $rep sec @ $FPS fps
        [V2dscan] A: $audiosize MB @ $audio_bitrate kbps";
        close(EXTRACT);
        system("touch tmp/extract-ok");
    } else {
        pinfo("$v2d\t Creating :\t\t\t\t   | tmp/extract.text\n");
        my $pid = fork();
        mydie "couldn't fork" unless defined $pid;
        if ($pid)
        {
            my $tmp = `tcprobe -i $VOBPATH/$sample 2>&1` or mydie "Error when running 'tcprobe -i $VOBPATH/$sample'";
            if ( $tmp =~ m,-e (\d+)\,(\d+)\,(\d+) \[\d+\,\d+\,\d+\],)
            {
                $bits=$2;
                $bits=16 if ( $bits == 0 );
                $tmp_channels=($3 > 2) ? 2 : $3;
                $audio_rate="$1,$bits,$tmp_channels";
            }
            print $DEBUG "\nAudio rate = $audio_rate \n";
            if ( $audio_format eq 'pcm' ) # Do not need to decode audio
            { 
                if (  $in_video_magic eq 'avi' )
                {
                    chk_wdir if ( ! defined($sample));
                    $sys = "nice -$nice tcextract -i \"$VOBPATH/$sample\" -x $audio_format | nice -$nice tcscan -b $audio_bitrate -x pcm -f $FPS -e $audio_rate 2>> tmp/extract.text  >> tmp/extract.text";
                } else {
                    $sys = "cat $VOBPATH/* | nice -$nice tcextract -x $audio_format -t $in_video_magic | nice -$nice tcscan -b $audio_bitrate -x pcm -f $FPS -e $audio_rate 2>> tmp/extract.text  >> tmp/extract.text";
                }
            } elsif (  $audio_format eq mp3  || $in_video_magic eq 'avi') {
                chk_wdir if ( ! defined($sample));
                $sys = "nice -$nice tcextract -i \"$VOBPATH/$sample\" -x $audio_format | nice -$nice tcdecode -x $audio_format | nice -$nice tcscan -b $audio_bitrate -x pcm -e $audio_rate -f $FPS 2>> tmp/extract.text  >> tmp/extract.text";
            } else {
                $sys = "cat $VOBPATH/* | nice -$nice tcextract -x $audio_format -t $in_video_magic | nice -$nice tcdecode -x $audio_format | nice -$nice tcscan -b $audio_bitrate -x pcm -e $audio_rate -f $FPS 2>> tmp/extract.text  >> tmp/extract.text";
            }
            print $INFO "\n$sys\n";
            print $DEBUG "+ Working directory ".`pwd`;
            system ("nice -$nice $sys") == 0  
                or ( 
                system("touch tmp/extract.finish") == 0 
                    and mydie "Unable to create extract.finish. $!" 
            ) ;
            system("touch tmp/extract.finish");
            wait;
            system("touch tmp/extract-ok");
        } else {
            smily(extract);
        }
    }
    print "\n";
    $duree=`cat tmp/extract.text`;
    $duree =~ m,estimated clip length=(\d+.\d+) seconds,;
    pinfo("$v2d\t Estimated Clip Length:\t\t\t   | $1 sec\n");
    print $DEBUG "<--- create_extract\n";
}

#  ***** Calculate How many Frames to encode ***** #

sub calculate_nbrframe
{
    print $DEBUG "---> Enter calculate_nbrframe\n";
    # We need Info about Clip

    if ( -e "tmp/probe.rip" && ! -e "tmp/probe.rip-BAD")
    {  	
        $info = `cat tmp/probe.rip`;
        $LOG="tmp/probe.rip";
    } else {
        create_extract if (! -e "tmp/extract-ok" || ! -e "tmp/extract.text" );
        $info = `cat tmp/extract.text`;
        $LOG="tmp/extract.text";
    }

    ($info =~ m,V: (\d+) frames,) or mydie "Unable to find number of frames to encode in $LOG" ;
    $tot_frames = $1;

    $info=`transcode -i $VOBPATH -c 1-2 2> /dev/null` or mydie "Problem when running \'transcode -i $VOBPATH\'";
    $info =~ m,V: encoding fps[^\|]*\| (\d+\.\d+).*,;
    $FPS=$1;
    if ( $FPS =~ m,29.97, && ! defined $TELECINE )
    {
       print(" Is this Movie a NTSC TELECINE movie (MPLayer is your friend to know that)?[y|N]");
       my $rep=<STDIN>;
        chomp($rep);
        $TELECINE=1; 
   }
    $VFORMAT="NTSC" if ( $FPS =~ m,2[39]\.9, );
#    create_nav if ( $VFORMAT eq "NTSC");

    $nbr_frames= floor($tot_frames - ($deb_sec+$last_sec)*$FPS);
    print $DEBUG "Number of frames: $nbr_frames\n";
    print $DEBUG "<--- calculate_nbrframe\n";
}

#  ********** Calculate Bitrate ****************

sub calculate_bitrate
{	
    print $DEBUG "--->  Enter calculate_bitrate\n";

    # We need Audio Bitrate
    a_bitrate if ( ! defined($audio_bitrate) );

    # And Also Info about Clip
    if ( -e "tmp/probe.rip" && ! -e "tmp/probe.rip-BAD" )
    {       
        $info = `cat tmp/probe.rip`;
        $LOG="tmp/probe.rip";
    } else {
        if (! -e "tmp/extract-ok" ||  ! -e "tmp/extract.text" )
        {
            create_extract;
        }
        $info = `cat tmp/extract.text`;
        $LOG="tmp/extract.txt";
    }

    ( $info =~ m,frames\, (\d+) sec @ ,) or mydie "Unable to find Video Runtime in $LOG";
    $fulltime=$1;
    mydie " ERROR : You said end credits is $last_sec sec. long, but this movie in only $fulltime sec." if ( $fulltime < $last_sec );
    $runtime=$fulltime - ($deb_sec+$last_sec);
    if ( $NOAUDIO != 1 )
    {
        ( $info =~ m, A: (\d+\.*\d*) MB @ ,) or mydie "Unable to find Audio Size in $LOG";
        $audio_size = $1*$runtime/$fulltime;
        ( $info =~ m, A: .* MB @ (\d+) kbps,) or mydie "Unable to find audio bitrate in $LOG";
        $audio_size = $audio_size*$audio_bitrate/$1;
        $audio_size=2*$audio_size if ( defined($ac2));
    } else {
        $audio_size = 0;
    }

    ask_filesize if ( ! $filesize );

    $bitrate = floor(($filesize - $audio_size)/$runtime * 1024 * 1024 * 8 / 1000);
    if ($bitrate < 20)
    {	
        pwarn("\n#### ATTENTION ####\n\tCalculated bitrate is $bitrate kbps, \n".
        "which does not make much sense, I'll use 700 kbps instead. \nFilesize will".
        " not match your preferred filesize. Sorry\n");
        print " Press Enter ->";
        $junk=<STDIN>;
        $bitrate = 700;
    }
    # audio_rescale for CLUSTER mode
    $info=`cat tmp/extract.text` if ( -f "tmp/extract.text");
    if ( $info =~ m,suggested volume rescale=(\d+.*\d+),)
    {
        $audio_rescale = $1;
    }
    print $DEBUG "Bitrate : $bitrate\n";

    print $DEBUG "<--- calculate_bitrate\n";

} # END calculate_bitrate

# ********** Main Avi encode ***************

sub aviencode
{
    print $DEBUG "--->  Enter aviencode\n";
    # Zooming MUST have been call before aviencode
    # zooming will give us $filesize $bitrate and 	Zoom
    $params .=" -$Zoom_mode ${NXaxis}x$NYaxis" if ($Zoom_mode eq Z);
    $params .=" -$Zoom_mode $zH,$zW,$row" if ($Zoom_mode eq B);

    printinfo if ( ! -e "tmp/cluster.args");
    # We are in Cluster Mode and there is no cluster args file ???
    # It means that we are in cluster mode on the master 
    # We call the cluster subroutine and will never return here
    cluster if ( $CLUSTER ne "NO" && ! -e "tmp/cluster.args");

    if (  $CLUSTER ne "NO" )	
    {
    # We are on an encoding node
    # We get the W parameters from tmp/cluster.args
        my $cluster=`cat tmp/cluster.args`;
        chomp($cluster);
        $node=`cat tmp/cluster.args| awk -F, '{print \$1}'`;
    # we can free the tmp/cluster.args for other nodes now
        system("touch tmp/node_started");
        chomp($node);
        $fparams="$params -W $cluster,tmp/file.nav";
        chomp($CLUSTER);
        $stream_unit=$CLUSTER;
    } else {
        $stream_unit=0;
        # Encode all frames (only if $last_sec AND $deb_sec < 600 ) , we'll split after
        if ( $deb_sec < 600 )
        {  
            $from_frames=0;
        } else {
            $from_frames=$deb_sec*$FPS}
            if ( $last_sec < 600 )
            { 
                $to_frames=$tot_frames; 
            } else { 
                $to_frames=$tot_frames-$last_sec*$FPS 
            }
            $fparams="$params -c $from_frames-$to_frames";
        }

        system("rm tmp/*.done  2> /dev/null");

        $start_frames_logo=floor(($deb_sec+$beginlogo)*$FPS);
        $end_frames_logo=floor($addlogo*$FPS+$start_frames_logo);

    # In cluster mode we MUST encode each sequence unit separatly 
    # In normal mode $stream_unit==0

        for ( $i=$stream_unit ; $i >= 0 ; $i--  )
        {      
            print("*** SEQ UNIT = $i ********\n***  Cluster NODE number : $node ******* \n")  if (  $CLUSTER ne "NO" );
            if ( $addlogo && $i == 0 && $CLUSTER eq "NO" )
            {
                $add_logo="logo=file=$LOGO:posdef=$poslogo:rgbswap=$RGBSWAP:range=$start_frames_logo-$end_frames_logo,";
            } else {
                $add_logo="";
            }
            $subtitle=$sub_title if ( $sub_title =~ m,extsub,);  # Bug 
            $filter=$deintl.$add_logo.$subtitle.",hqdn3d";# Use now hqdn3d filter                        
            # WE NEED the next 4 lines  because in non cluster mode we do not need $stream_unit value, 
            # And WE want encode all the sequences unit (so, no -S option) .
            if ( $stream_unit != 0 )
            {	
                $stream_opt="-S $i,all";
            } else {       
                $stream_opt="";
            }

            $params =~ m/-a (\d) .*/;
            $audio_params="-a $1";
            $audio_format=audioformat("$audio_params") if ( ! defined($audio_format));
            # Only ONE FILE allowed if input Video type is AVI, QT, DV , MPEG2
            $VOBPATH="$VOBPATH/$sample" if ( $in_video_magic eq divx || 
            $in_video_magic eq mov || 
            $in_video_magic eq 'mpeg2'  || 
            $in_video_magic eq dv  );
            # Let transcode find it, if input audio type is "declared" as PCM
            $audio_format="" if ( $audio_format eq pcm );
            $audio_format="vob" if ( $in_video_codec eq vob );

            # Add NTSC demuxer opts
            $fparams =$fparams." -M 2 " if ( $VFORMAT eq "NTSC" && ! ($deintl =~ m,ivtc,));
            $fparams =$fparams." -M 0 -f 23.976" if ( $deintl =~ m,ivtc,);
#            $fparams =$fparams." --psu_mode --nav_seek tmp/file.nav --no_split " if ( $CLUSTER eq "NO" && $VFORMAT eq "NTSC" );
            $clust_percent=" --a52_dolby_off " if ( $VFORMAT eq "NTSC" && $CLUSTER eq "NO" );

            # And Now ... Let the Rolling Stones

            if (! -e "tmp/1-${dvdtitle}${node}_${i}.finish")
            {
                unlink("tmp/2-${dvdtitle}${node}_${i}.finish");
                unlink ("tmp/1-${dvdtitle}${node}.PB");
                pinfo("$v2d\t Encode: $VOBPATH Pass One ....\n");
                $sys = "transcode -i $VOBPATH $stream_opt $clust_percent $fparams -w $bitrate,$keyframes -J ${filter},astat=\"tmp/astat\" -y $DIVX,null $DIVX_OPT -x $in_video_codec,$audio_format $VID_OPT -R 1,tmp/$DIVX.${dvdtitle}${node}_${i}.log -o /dev/null"; 
                print $INFO "$sys\n";
                my $pid = fork();
                mydie "couldn't fork" unless defined $pid;
                if ($pid)
                {
                    wait;
                    if ( -f "tmp/1-${dvdtitle}${node}.PB")
                    {    
                        mydie("\t\t**** Pass One failed on node(${node}),seq(${i}) ****.\n\tFailed to execute:\n $sys")
                    }
                    system("touch tmp/1-${dvdtitle}${node}_${i}.finish");
                } else {
                    system("nice -$nice $sys")==0 or system("touch tmp/1-${dvdtitle}${node}.PB");
                    print "\n";
                    exit(0);
                }
            } else {
                pwarn("${dvdtitle}${node}_${i} already encoded, remove \"tmp/1-${dvdtitle}${node}_${i}.finish\" to reencode \n");
            }
            audiorescale;
            if (! -e "tmp/2-${dvdtitle}${node}_${i}.finish")
            {
                unlink ("tmp/2-${dvdtitle}${node}.PB");
                $filter="$filter,dnr,normalize";	
                $filter="-J $filter" if ( $filter ne "" );
                unlink("tmp/merge.finish");	
                unlink("tmp/finish");
                pinfo("$v2d\t Encode: $VOBPATH Pass Two ....\n");
                $sys = "transcode -i $VOBPATH $stream_opt $clust_percent $fparams -s $audio_rescale -w $bitrate,$keyframes -b $audio_bitrate,0 -y $DIVX  $DIVX_OPT -x $in_video_codec,$audio_format $VID_OPT $filter -R 2,tmp/$DIVX.${dvdtitle}${node}_${i}.log -o tmp/2-${dvdtitle}${node}_${i}.avi";
                print $INFO "$sys\n";
                my $pid = fork();
                mydie "couldn't fork" unless defined $pid;
                if ($pid)
                {    
                    wait;
                    if ( -f "tmp/2-${dvdtitle}${node}.PB") 
                    { 
                        mydie("\t\t**** Pass Two failed on node(${node}),seq(${i}) ****.\n\tFailed to execute:\n $sys"); 
                    }        
                    system("touch tmp/2-${dvdtitle}${node}_${i}.finish");
                } else {	
                    system("nice -$nice $sys")==0 or system("touch tmp/2-${dvdtitle}${node}.PB");
                    print"\n";
                    exit(0);
                }
            } else {	
                pwarn("${dvdtitle}${node}_${i} already encoded, remove \"tmp/2-${dvdtitle}${node}_${i}.finish\" to reencode \n");
            }
        } # end boucle for
        if ( $CLUSTER ne "NO")
        {       
            print ("Finish ... Wait \n ");
            sleep(3);
        }
        print $DEBUG "<--- aviencode\n";
    } # END Aviencode

# ********* MERGING ( and syncing )Function **************#

sub merge
{	
    print $DEBUG "--->  Enter merge\n";
    if (! -e "tmp/merge.finish" )
    {       
        unlink("tmp/sync.finish"); 
        unlink("tmp/finish");
        pinfo("$v2d\t Merging the sequence units\n");
        my $pid = fork();
        mydie "couldn't fork" unless defined $pid;
        if ($pid)
        {	
            wait;
            system("touch tmp/merge.finish");
        } else {	
            # $CLUSTER  is known because we've pass through aviencode before
            for ( $i=$CLUSTER ; $i >= 0 ; $i-- )
            { 	
                pinfo("$v2d\t Seq. unit :\t\t\t   | $i\n");
                $sys = "avimerge -i tmp/2-*_$i.avi -o tmp/tmp_movie_$i.avi";
                print $INFO "$sys\n";
                system("nice -$nice $sys 1> /dev/null");
            }
            if ( $CLUSTER > 0 )
            {
                $sys = "avimerge -i tmp/tmp_movie_*.avi -o tmp/2-$dvdtitle.avi && rm tmp/tmp_movie_*.avi";
                print $INFO "$sys\n";
                system("nice -$nice $sys 1> /dev/null");
            } else {
                rename("tmp/tmp_movie_0.avi","tmp/2-$dvdtitle.avi");
            }
            exit(0);
        }
    } else {       
        pwarn("*.avi of $dvdtitle are already merge ... remove \"tmp/merge.finish\" to re-merge it\n");
    }
    print $DEBUG "<--- merge\n";


    ######## add audio in cluster mode #############

    print $DEBUG "--->  Enter synchro\n";
    audiorescale;
    if (! -e "tmp/sync.finish" )
    {	
        unlink("tmp/finish");
        unlink("tmp/sync.done") if ( -e "tmp/sync.done" );
        # We need to catch the keyframe...
        $from_frames=$deb_sec*$FPS;
        $to_frames=$tot_frames-$last_sec*$FPS;
        $synclogo=int(($end_frames_logo+$keyframes)/$keyframes)*$keyframes;
        if ( $addlogo ne 0 && $addlogo <= 300 )
        {	 
            $start_frames=$synclogo;
        } else {
            $start_frames=$from_frames;
        }
        $params =~ m/-a (\d) .*/;
        $audio_params="-a $1";
        pinfo("$v2d\t Merging Video and Audio streams\n");
        my $pid = fork();
        mydie "couldn't fork" unless defined $pid;
        if ($pid)
        {       
            wait;
            system("touch tmp/sync.finish");
        } else {
            $sys = "transcode -p $VOBPATH $audio_params -b $audio_bitrate -c $start_frames-$to_frames -s $audio_rescale -i tmp/2-$dvdtitle.avi -P 1 -x avi,vob -y raw -o tmp/2-${dvdtitle}_sync.avi -u 50";
            print $INFO "$sys\n";
            system("nice -$nice $sys")==0 or mydie "Unable to merge Audio and Video";
            unlink("tmp/enc_audiochannel2.finish") if ( -e "tmp/enc_audiochannel2.finish");
            exit(0);
        }
    } else {	
        pwarn("$dvdtitle is already sync, remove \"tmp/sync.finish\" to re-sync it\n");
    }
    print $DEBUG "<--- synchro\n";
} # END merge

# ######## Encode the optionnal second audio channel ########## #

sub twoac
{
    print $DEBUG "---> Enter twoac\n";
    return() if ( ! defined($ac2));
    audioformat("-a $ac2");
    if ( ! -e "tmp/enc_audiochannel2.finish" )
    { 	 
        unlink("tmp/finish") if ( -e "tmp/finish");
        unlink("tmp/audiochannel2.finish" ) if ( -e "tmp/audiochannel2.finish" );
        pinfo("$v2d\t Encoding the second audio channel\n");
        $sys="transcode -i $VOBPATH -x null -s $audio_rescale -b $audio_bitrate -g 0x0 -y raw -a $ac2  -o add-on-ac2.avi -u 50";
        print $INFO $sys."\n";
        system("nice -$nice $sys")==0 or mydie "Unable to encode the second audio channel";
        system("touch tmp/enc_audiochannel2.finish") ;
        print"\n";
    }
    if ( ! -e "tmp/audiochannel2.finish" )
    {
        unlink("tmp/finish") if ( -e "tmp/finish");
        pinfo("$v2d\t Merging the second audio channel\n");
        $sys="avimerge -i tmp/2-${dvdtitle}_sync.avi -o tmp/3-${dvdtitle}_2ac.avi -p add-on-ac2.avi";
        print $INFO "$sys\n";
        system("nice -$nice $sys 1> /dev/null")==0 or mydie "Unable to merge movie and second audio channel";
        rename("tmp/3-${dvdtitle}_2ac.avi","tmp/2-${dvdtitle}_sync.avi") && system("touch tmp/audiochannel2.finish") ;
    }
    print $DEBUG "<--- twoac\n";
} # END 2ac

# ############ Finish the work ############# #

sub finish
{
    print $DEBUG "---> Enter finish\n";
    if (! -e "tmp/finish")
    {
        $from_frames=$deb_sec*$FPS;
        $to_frames=$nbr_frames+$from_frames;
        if ( ($CLUSTER eq NO && ($last_sec eq 0 || $last_sec > 600) &&  ($deb_sec eq 0  || $deb_sec > 600)) || $CLUSTER ne NO )
        {
            makelogo if ( $CLUSTER ne NO && $add_logo );
            pinfo("$v2d\t Renaming tmp/2-${dvdtitle}_sync.avi $dvdtitle.avi\n");
            rename("tmp/2-${dvdtitle}_sync.avi","$dvdtitle.avi");
        } else {
            # avisplit takes arguments in HH:MM:SS format in transcode
            # 0.6.11. Maybe we should detect what version of transcode
            # people are using before doing this. - Luis Mondesi
            # If the movie is 2 Hours long and you want to cut from
            # 30 seconds up to 1:55 hours, then you will pass
            # deb_sec = 30;
            # last_sec = ( 5 * 60 ); # to cut 5 minutes from the end 
            #                        # the movie
            my $start_of_file_hour = sec_to_hour($deb_sec);
            my $end_of_file_hour = 
            sec_to_hour( int($tot_frames / $FPS) - $last_sec );

            $sys="avisplit -t $start_of_file_hour-$end_of_file_hour -i  tmp/2-${dvdtitle}_sync.avi -o $dvdtitle.avi && mv $dvdtitle.avi-0000 $dvdtitle.avi";
            pinfo("$v2d\t Splitting the result to $nbr_frames frames.\n");
            print $INFO "$sys\n";
            system("nice -$nice $sys");
        }
        system("touch tmp/finish");
    }

    # substract unixtimestamp from our original timestamp
    my $end_time = time - $start_time;
    my $f_end_time = format_date($end_time,"hours");
    print "Number of Hours: $f_end_time \n";
    if ( -x "/usr/bin/flite" )
    {
        # say it outloud using "flite" speech synthetizer
        system("/usr/bin/flite -t 'Number of hours $f_end_time'");
    }

    print " Now take a look at the end of $dvdtitle.avi\n".
    "\t If for some reason the divx file doesn't reach the end credits,".
    " just edit tmp/V2divx.conf, decrease the \$last_sec value, ".
    "remove the tmp/finish file and then run V2divx without ".
    "parameters.";
    print " Is you divx file OK? (y/N): ";
    $rep=<STDIN>;
    chomp($rep);
    if ($rep eq "O" or $rep eq "o" or $rep eq "y" or $rep eq "Y")
    {
        print "May I clean the tmp directory and other temporaries and log files ? (y/N): ";
        $rep=<STDIN>;
        chomp($rep);
        if ($rep eq "O" or $rep eq "o" or $rep eq "y" or $rep eq "Y")
        {
            rename("tmp/dvdtitle",$VOBPATH."/dvdtitle") if ( -e "tmp/dvdtitle" );
            rename("tmp/probe.rip",$VOBPATH."/probe.rip") if ( -e "tmp/probe.rip" );
            system("/bin/rm -rf tmp/*  db *.bak video_s._-j_* audio_sample* add-on-ac2.avi");
        }
    }
    print $DEBUG "<--- finish\n";
    mydie $NORM."Bye !!!";
}  # ENd finish


#   *************   Get Audio Bitrage ************ #

sub a_bitrate
{      	
    print $DEBUG "--->  Enter Audio_bitrate\n";
    $audio_bitrate ='null' if ( $NOAUDIO == 1 );
    while ( $audio_bitrate ne 'null' && $audio_bitrate ne 32 && $audio_bitrate ne 48 && $audio_bitrate ne 64 && $audio_bitrate ne 96 && $audio_bitrate ne 128 && $audio_bitrate ne 256 )
    {
        print " Enter the desired MP3 Audio output bitrate (Kb/s) [default:128]: ";
        $audio_bitrate=<STDIN>;
        chomp($audio_bitrate);
        if ( $audio_bitrate eq "" )
        {
            $audio_bitrate=128;
            last;
        }
    }
    $audio_bitrate=0 if  ( $audio_bitrate eq 'null');
    open (CONF,">>tmp/V2divx.conf");
    print CONF "#audio_bitrate:$audio_bitrate\n";
    close CONF;	
    print $DEBUG "<--- Audio_bitrate\n";
}

# ******** Read actual conf ********** #
sub readconf
{
    print $DEBUG "---> Enter readconf\n";
    if ( -e "tmp/V2divx.conf")
    {
        open (CONF,"<tmp/V2divx.conf");
        while (<CONF>)
        {       
            chomp;
            s[/\*.*\*/][];      #  /* comment */
            s[//.*][];          #  // comment
            s/^#//;		    # 	Remove the first #
            s/#.*//;            #  # comment
            s/^\s+//;           #  whitespace before stuff
            s/\s+$//;           #  whitespace after stuff
            next unless length; #  If our line is empty, we ignore it
            my ($var_name, $value) = split(/:/, $_);
            $$var_name = $value;
        }
        close(CONF);
    }
    print $DEBUG " VOBPATH :$VOBPATH\n";
    print $DEBUG " PARAMS :$params\n";
    print $DEBUG " FILESIZE:$filesize\n";
    print $DEBUG " CLUSTER :$CLUSTER\n";
    print $DEBUG " audio_bitrate :$audio_bitrate\n";
    print $DEBUG " dvdtitle:$dvdtitle\n";
    print $DEBUG "<--- readconf\n";
} # end readconf

#  ************* Get Needed parameters ************ #
sub get_params
{  	
    print $DEBUG "--->  Enter get_params\n";
    if ( ! -e "tmp/V2divx.conf")
    {
        # We are in Quick Mode
        $i = 0;
        if ( $ARGV[$i])
        {	
            $VOBPATH= $ARGV[$i];
            $i ++;
        } else {	
            system ("echo \"$readme\" | less -R ");
            if ( $DVDTITLE eq "" ) 
            {
                print $urldvdtitle;
            }
            exit(0);
        }
        mydie "Path: $VOBPATH does not exist." if (! -e $VOBPATH);
        umask(000); # resets current umask values. Luis Mondesi
        mkdir ("tmp",01777);
        # Luis Mondesi <lemsx1AT_NOSPAM_hotmail.com> 
        # how does the script knows that the "sample" keyword
        # was given?
        if ($ARGV[$i] > 1)
        {	
            $filesize = $ARGV[$i];
        } else {
            mydie "\'$ARGV[$i]\' is not a valid filesize.\n Please supply filesize \n\t or \"sample\" if you want to create samples for cropping.";
        }
    } else {   
        # We are in 'continue' mode
        readconf;
    }

    $audio_bitrate=128 if ( ! defined($audio_bitrate));	
    tv_recorder if ( $TVREC );
    chk_wdir;
    ask_clust if (! defined($CLUSTER) );

    #   For Quick mode only .....	

    if ( ! defined($params) ) 
    {
        $dvdtitle=movie if ( ! defined ($dvdtitle));
        findclip;
        get_audio_channel if ( ! defined($audio_channel));
        interlaced;
        if ( $INTERLACE eq yes )
        {
            $PP=`transcode -J pp=lb -c 9-11  2>&1 | grep failed`;
            if ( $PP eq "" )
            {	
                $deintl=",pp=lb";
            } else {
                $params=" -I 3 ";
            } 
        }
        $params .= "-a $audio_channel " if ( $audio_channel ne '' );
        $params .= "-j $tb,$lr";
    }
    zooming;
    if ( ! defined($addlogo) && -e $LOGO )
    {
        $LG=`transcode -J logo=help -c 9-11  2>&1 | grep rgbswap`;
        if ( $LG ne "" )
        {
            $beginlogo=$STARTLOGO;  
            if ( $TIMELOGO+$beginlogo > $runtime)
            {
                $addlogo=$runtime-$STARTLOGO;
            } else {
                $addlogo=$TIMELOGO;
            }
            $poslogo=$POSLOGO;
        } else {
            pwarn("Transcode is not compile with ImageMagick.\nUnable to encode your Logo $LOGO\n"); 
            sleep(1);
        }
    }

    # End Quick mode Configuration


    $dvdtitle=movie if ( ! defined($dvdtitle));

    open(CONF,">tmp/V2divx.conf");
    if ( defined($VOBPATH) ) {
        print CONF "#VOBPATH:$VOBPATH# DO NOT MODIFY THIS LINE\n";
    }
    if ( defined($last_sec) ) {
        print CONF "#last_sec:$last_sec\n";
    }
    if ( defined($deb_sec) ) {
        print CONF "#deb_sec:$deb_sec\n";
    }
    if ( defined($audio_bitrate) ) {
        print CONF "#audio_bitrate:$audio_bitrate\n";
    }
    if ( defined($filesize) ) {
        print CONF "#filesize:$filesize\n";
    }
    if ( defined($addlogo) ){
        print CONF "#addlogo:$addlogo # THIS VALUE IS THE DURING TIME OF LOGO (in sec.)\n";
    }
    if ( defined($beginlogo) ){
        print CONF "#beginlogo:$beginlogo\n";
    }
    if ( defined($poslogo) ){
        print CONF "#poslogo:$poslogo\n";
    }
    if ( defined($dvdtitle) ){
        print CONF "#dvdtitle:$dvdtitle # DO NOT MODIFY THIS LINE\n";
    }
    if ( defined($params) ) {
        print CONF "#params:$params# YOU MUST KNOW WHAT YOU DO IN THIS LINE\n";
    }
    if ( defined($CLUSTER) ) {
        print CONF "#CLUSTER:$CLUSTER # YOU CAN REMOVE BUT NOT MODIFY THIS LINE\n";
    }
    if ( defined($sub_title) ) {
        print CONF "#sub_title:$sub_title\n";
    }
    if ( defined($deintl) ) {
        print CONF "#deintl:$deintl\n";
    }
    if ( defined($ac2) ) {
        print CONF "#ac2:$ac2\n";
    }
    if ( defined($VFORMAT) ) {
        print CONF "#VFORMAT:$VFORMAT\n";
    }
    if ( defined($TELECINE) ) {
        print CONF "#TELECINE:$TELECINE\n";
    }


    close(CONF);

    print $DEBUG "<--- get_params\n";
} # end get params

# ##################### Audio Input format ###################

sub audioformat
{
    print $DEBUG "---> Enter audioformat\n";
    if ( $NOAUDIO == 1 )
    {
        $audio_format=null;
        return($audio_format);
        print $DEBUG "<--- Audio_format\n";
    }
    @_[0] ="-a 0" if (! defined(@_[0]));
    return("null") if ( @_[0] eq "-a null");
    my $audio_format=`tcprobe -i "$VOBPATH/$sample" 2> /dev/null ` or mydie "Problem when running \'tcprobe -i ".$VOBPATH."/".$sample."\'";
    ( $audio_format =~ m,audio track: @_[0] [^n]*n 0x(\d+) .*,) or mydie "Unable to find audio channel ".@_[0]." format";
    my $tmp=$1;
    SWITCH: 
    {
        # FIXME
        if ( $tmp == 2000 ) {
            $audio_format=ac3 ; last SWITCH;
        }
        if (  $tmp == 1 ) {
            $audio_format=pcm ; last SWITCH;
        }
        if ( $tmp == 10001 ) {
            $audio_format=pcm ; last SWITCH;
        }
        if ( $tmp eq "1000F" ) {
            $audio_format=dts ; last SWITCH;
        }
        if ( $tmp == 55  || $tmp == 50 ) # mpeg2ext is mp3
        {
            $audio_format=mp3;
            $MP3=`transcode -x null,mp3 -c 0-1 2>&1 | grep failed`;
            mydie("\n *******   WARNING !! *************\n It seems that your transcode is'nt compiled with lame , it's not able to encode this audio channel \n\n") if  ( $MP3 ne "" );
            last SWITCH;
        }
        mydie "Unable to find a known audio format ($tmp is unknown)";
    }
    print $DEBUG "<--- Audio_format\n";
    return($audio_format);
}

#sub videoformat_old
#{
#    print $DEBUG "---> Enter videoformat\n";
#    $in_video_magic='vob' if ( $probe =~ m,MPEG program stream,);
#    $in_video_magic='mov' if ( $probe =~ m,QuickTime movie,);
#    $in_video_magic='m2v' if ( $probe =~ m,elementary stream,);
#    $in_video_magic='vdr' if ( $probe =~ m,Digital Video,);
#    $in_video_magic='avi' if ( $probe =~ m,RIFF data\, AVI video,);
#    $in_video_codec='mpeg2' if ( $probe =~ m,MPEG .* stream,);
#    $in_video_codec='mpeg2' if ( $probe =~ m,elementary stream,);
#    $in_video_codec='dv' if ( $probe =~ m,Digital Video,);
#    $in_video_codec='dv' if ( $probe =~ m,codec=[Dd][vV][sS][dD],);
#    $in_video_codec='ffmpeg' if ( $probe =~ m,codec=[mM][jJ][pP][gG],);
#}

sub videoformat
{    
    $in_video_magic=""; # reset var
    print $DEBUG "---> Enter videoformat\n";
    print $DEBUG "+ transcode -c 0-1  -i @_[0]\n";
    $VID_OPT="-V";
    $RGBSWAP=1;
    $REV_VID='-z -k';
    my $probe=`transcode -c 0-1 -i @_[0] 2>&1 `;
    $in_video_magic=$1 if ( $probe =~ m,V=([^\|.]*)\|A=,);
    print $DEBUG "+ Type of video: $in_video_magic \n";
    if ( $in_video_magic eq 'mov' && $DIVX_OPT ne "mpeg4" )
    {
        # FIXME .. at least for dvc video format ?
        $VID_OPT='-z -k';
        $REV_VID=' ';
        # Make nothing ?? FIXME		$RGBSWAP=0;
    }
    if ( $in_video_magic =~ m/^.{0,1}null.{0,1}$/ && $SVIDEO_FORMAT eq "" )
    { 
        # Trying with tcprobe .. 
        # in this case We need audio_codec also !!
        pwarn($v2d."\tTranscode failed to find Video format, trying with tcprobe\n You could also override with --source-video-format='TYPE'. See Help for more\n");
        my $probe2=`tcprobe -i @_[0] 2>&1`;
        $in_video_magic='divx' if ( $probe2 =~ m,codec=[dD][xX]50,);
        $in_video_magic='divx' if ( $probe2 =~ m,codec=[dD][iI][vV][3xX],);
        # DOES NOT WORK $in_video_magic='avi' if ( $probe2 =~ m,codec=[Ii][vV]32,);
        print $DEBUG  "tcprobe has detect : $in_video_magic \n";
    }
 
    # assigned the command line option --source-video-format
    # to in_video_codec
    if ( $SVIDEO_FORMAT ne '' ) 
    {
        # backward compatibility:
        $in_video_magic=$SVIDEO_FORMAT;
        $in_video_codec=$SVIDEO_FORMAT;
    }
   
    $in_video_codec="$in_video_magic";
    print $DEBUG "<--- videoformat : $in_video_magic \n";
    mydie "$v2d\t$_[0]: Unknown file type. ".
    "Please use --source-video-format='TYPE' to force a given type" 
    if ( $in_video_magic =~ m/^.{0,1}null.{0,1}/ && $SVIDEO_FORMAT eq '' );

    if ( $in_video_magic eq 'dv' )   # Need to know the container (raw,avi?)
    {
        print $DEBUG "DV File ... need to know the container ...\n";
        #        my $probe2=`tcprobe -i @_[0] 2>&1`;
        #        
        #        need_time means that tcextract does not work for this
        #        Video format and then user MUST enter video run time :-( 
        $need_time=1; #   if ( $probe2 =~ m,Digital Video,);
        $VID_OPT="";    # Bug transcode ? Crash if we use -V
        # PB with Logo if input is DV ? 
    }

    # WARNING Sometime transcode is unable to find formats ... 
    # use tcprobe (videoformat_old) in this case to 
}

#******************* Make Audio sample **************
sub make_sample
{
    @actmp=split /-a/,@_[0];
    @actmp=split / /,@actmp[1];
    print $DEBUG "Params for sound Samples are: @_[0], on file  @_[1], frames=@_[2]\n";
    pinfo("$v2d\t Making a sound sample audio channel:\t   | @actmp[1]\n");
    @_[2] = 1000 if (! defined(@_[2]));
    audioformat ("-a ".@actmp[1]);
    my $pid = fork();
    mydie "couldn't fork" unless defined $pid;
    if ($pid)
    {
        $sys = "transcode -q 0 -i \"$VOBPATH/$sample\" @_[0] -w 100,@_[2] -c 0-@_[2] -o @_[1].avi 2> /dev/null";
        print $INFO $sys."\n";
        system ("nice -$nice $sys") == 0 or ( system("touch tmp/sample.finish") && mydie "Unable to run\'$sys\'");
        system("touch tmp/sample.finish");
        wait;
    } else {
        smily(sample);
    }
}

sub ask_filesize
{
    print " Enter the maximal avifile size (in MB): ";
    $filesize=<STDIN>;
    chomp($filesize);
    open(CONF,">>tmp/V2divx.conf");
    print CONF "#filesize:$filesize\n";
    close(CONF);
}


sub ask_logo
{
    $LG=`transcode -J logo=help -c 9-11  2>&1 | grep rgbswap`;
    if ( $LG ne "" )
    {
        if ( -r $LOGO )
        {       
            print " Do you want to add the Logo $LOGO at the beginning of this movie (Y/n)? ";
            $rep= <STDIN>;
            chomp($rep);
            if ( $rep ne "N" && $rep ne "n" )
            {
                print " How many seconds after the movie beginning  must be your Logo displayed (MAX=$runtime - see your $userconfigfile for [default:$STARTLOGO]): ";
                $beginlogo=<STDIN>;
                chomp($beginlogo);
                $beginlogo=$STARTLOGO if ( $beginlogo eq ""  ) ;
                while ( ! defined($addlogo) || $addlogo + $beginlogo > $runtime )
                {
                    $MAX=$runtime-$beginlogo;
                    $TIMELOGO=$MAX if ( $MAX < $TIMELOGO);
                    print "How long (in sec.) should your Logo be displayed (MAX=$MAX - see your $userconfigfile for [default:$TIMELOGO])? ";
                    $addlogo=<STDIN>;
                    chomp($addlogo);
                    $addlogo=$TIMELOGO if ( $addlogo eq "" || $addlogo == 0 ) ;
                }
                pwarn("\t**** WARNING *****\As your logo timing is > 300 sec., it will NOT be encoded in CLUSTER mode !!!\n") if ( $addlogo > 300 );
                print " Where must appear your Logo (1=TopLeft,2=TopRight,3=BotLeft,4=BotRight,5=Center, see your $userconfigfile for [default:$POSLOGO]): ";
                $poslogo=<STDIN>;
                chomp($poslogo);
                $poslogo=$POSLOGO if ( ! ($poslogo =~ m,[12345],));
            } else {
                $addlogo=0;
            }
        } else {
            pwarn("\tIf you want to add a Logo at the beginning of this movie \n\t You must modify the \$LOGO variable, which point to your image file (actually $LOGO), in $userconfigfile\n");
            $junk=<STDIN>;
            $addlogo=0;
        }
    } else
    {
        pwarn("Transcode is not compile with ImageMagick... Unable to encode your Logo $LOGO\n") if  ( -r $LOGO );
        $addlogo=0;
    }      
    open(CONF,">>tmp/V2divx.conf");
    print CONF "#addlogo:$addlogo # THIS VALUE IS THE DURING TIME OF LOGO (in sec.)\n";
    print CONF "#poslogo:$poslogo\n" if ( defined($poslogo));
    print CONF "#beginlogo:$beginlogo\n" if ( defined($beginlogo));
    close(CONF);
}
# END ask_logo


#******************Evaluate the Zoom*********************
sub zooming
{
    print $DEBUG "---> Enter Zooming\n";
    # We need the Bitrate to calculate new image Size for the bpp
    calculate_bitrate;
    #       We need also the Frame rate $FPS
    calculate_nbrframe if ( ! defined ($nbr_frames));

    $probe = `tcprobe -i  "$VOBPATH/$sample" 2> /dev/null ` or mydie "Problem when running \'tcprobe -i $VOBPATH/$sample\'";

    ($probe =~ m,import frame size: -g (\d+)x,) or mydie "Unable to find Width image size";
    $Xaxis=$1;

    ( $probe =~ m,import frame size: -g \d+x(\d+).*,) or mydie "Unable to find Hight image size";
    $Yaxis=$1;

    ( $probe =~ m,aspect ratio: (\d+):(\d+).*,) or ( $probe =~ m,frame size: -g (\d+)x(\d+).*,) or mydie "Unable to find Image Aspect ratio";
    $aspect_ratio=$1/$2;
    print $DEBUG " PARAMS = $params\n";
    $params =~ m/-j (\d+),(\d+).*/;
    $tb=$1;
    $lr=$2;
    print $DEBUG "Top/Bot crop= $tb, Lef/Right crop = $lr \n";

    # New in 1.0.2
    $visual_Yaxis=$Xaxis/$aspect_ratio;
    $aspect_ratio=($Xaxis-2*$lr)/($visual_Yaxis*(1-2*$tb/$Yaxis));

    if ( $Yaxis-2*$tb > 0 && $Xaxis-2*$lr > 0 )
    {
        $bpp=$bpp*$Yaxis*$Xaxis/(($Yaxis-2*$tb)*($Xaxis-2*$lr));
    } else {	
        mydie  "Something crazy !! Your image has a null or negative Size?\nAre you trying holographics movie ;-)?\n transcode is bad to do that ....";
    }

    # New Width Image = SQRT (Bitrate * aspect / QualityRatio x FPS )
    $NXaxis=sqrt(1000*$bitrate*$aspect_ratio/($bpp*$FPS));
    print $DEBUG "$NXaxis=sqrt(1000*(Vbitrate)$bitrate*(A_R)$aspect_ratio/((bpp)$bpp*(fps)$FPS))\n";
    # Finale Image MUST have a multiple of 16 size
    @NXaxis[1]=16*floor($NXaxis/16);
    @NXaxis[2]=16*ceil($NXaxis/16);
    # Limits 	
    for ( $i=1 ; $i<3 ; $i++ )
    {
        @NXaxis[$i]= 16*floor(($Xaxis-2*$lr)/16) if ( @NXaxis[$i] > $Xaxis-2*$lr );
        @NXaxis[$i]= 720 if ( $NXaxis > 720 );
        @NXaxis[$i]= 320 if ( $NXaxis < 320);
    }

    #                       New Height
    # Finale Image MUST have a multiple of 16 size
    @NYaxis[1]=16*floor((@NXaxis[1]/$aspect_ratio)/16);
    @NYaxis[2]=16*ceil((@NXaxis[1]/$aspect_ratio)/16);
    @NYaxis[3]=16*floor((@NXaxis[2]/$aspect_ratio)/16);
    @NYaxis[4]=16*ceil((@NXaxis[2]/$aspect_ratio)/16);

    # If we can find similar AR with better BPP ... get it !
    # Avec 1 poids de 110, si AR varie de 1% , BPP ne doit pas varier de plus de 0.009 bpp (1/110)
    $weight=110;
    # Quality = BPP*weight-%aspect_ratio_error 
    $Quality=$weight*1000*$bitrate/(@NXaxis[1]*@NYaxis[1]*$FPS)-abs(@NXaxis[1]/@NYaxis[1]-$aspect_ratio)*100/$aspect_ratio;
    for ( $i=1; $i < 5 ; $i++ )
    {	
        for ( $j=1; $j<3; $j++ )
        {
            print $DEBUG "---------------------\n";	
            printf($DEBUG " bpp=%.3f",1000*$bitrate/(@NXaxis[$j]*@NYaxis[$i]*$FPS));
            printf($DEBUG " and AR_err=%.3f %\n",abs(@NXaxis[$j]/@NYaxis[$i]-$aspect_ratio)*100/$aspect_ratio);
            $tmp=$weight*1000*$bitrate/(@NXaxis[$j]*@NYaxis[$i]*$FPS)-abs(@NXaxis[$j]/@NYaxis[$i]-$aspect_ratio)*100/$aspect_ratio;
            printf($DEBUG "Quality = %.6f\n",$tmp);
            if ( $tmp >= $Quality)
            { 	
                $Quality=$tmp;
                $NXaxis=@NXaxis[$j];
                $NYaxis=@NYaxis[$i];
                $fbpp=1000*$bitrate/($NXaxis*$NYaxis*$FPS);
                print $DEBUG "X($j)=$NXaxis, Y($i)=$NYaxis ---CATCH !! \n";
            }
        }
    }
    # Limits but normally impossible to fall into
    if ( $NXaxis > $Xaxis )
    { 
        $NXaxis=16*ceil(($Xaxis-2*$lr)/16);
        $NYaxis=16*ceil(($NXaxis/$aspect_ratio)/16);
    }
    if ( $NYaxis > $Yaxis )
    {
        $NYaxis=16*ceil(($Yaxis-2*$tb)/16);
        $NXaxis=16*ceil(($NYaxis*$aspect_ratio)/16);
    }

    #  zH zW and row are the -B parameters
    $row=16;
    $zH=floor(($Yaxis-2*$tb-$NYaxis)/$row);
    $zW=floor(($Xaxis-2*$lr-$NXaxis)/$row);
    if ( 
        ($Xaxis - 2*$lr)/16 == floor(($Xaxis - 2*$lr)/16) 
        && ($Yaxis - 2*$tb)/16 == floor (($Yaxis - 2*$tb)/16) 
    )
    {
        pinfo("$v2d\t Slow Zooming is necessary:\t\t   | NO\n") if ( ! -e "tmp/cluster.args");
        $Zoom_mode="B";
    } else {
        pinfo("$v2d\t Slow Zooming is necessary:\t\t   |$RED YES\n") if ( ! -e "tmp/cluster.args");
        $Zoom_mode="Z";
    }
    sleep(1);
    $AR=abs(100-($NXaxis*100/($NYaxis*$aspect_ratio)));
    print $DEBUG "<--- Zooming\n";
} # end zooming

# ********************** Config ****************************

sub config
{       
    print $DEBUG "--->  Enter config\n";
    mydie "There is still a tmp/V2divx.conf , please remove all tmp files\n (or at least tmp/V2divx.conf) before running V2divx /path/to/vob sample" if ( -e "tmp/V2divx.conf") ;
    $VOBPATH= $ARGV[0];
    mydie "Directory \"$VOBPATH\" does not exist \n Sorry" if ( ! -e $VOBPATH);
    umask(000); #reset current umask values. Luis Mondesi
    mkdir ("tmp",01777);
    chk_wdir;

    open(CONF,">>tmp/V2divx.conf");
    print CONF "#VOBPATH:$VOBPATH# DO NOT MODIFY THIS LINE\n";
    close(CONF);

    print "\n You will have a look with \'$XINE\' on the File $lastvob.\n Look how long (in seconds) is the end credits (so we can remove it),\n you also may find which audio stream and subtitle number you will choose.\n";
    print " Press Enter -> ";
    $junk=<STDIN>;
    system ("$XINE $VOBPATH/$lastvob >/dev/null 2>&1");
    # How many second remove from end of movie...
    print " How long (in seconds) are the end credits (we will not process it and so increase video bitrate) [default:0]? "; 
    $last_sec=<STDIN>;
    chomp($last_sec);

    $last_sec=0 if ( $last_sec eq "" || $last_sec < 10 );
    print " How many seconds will you remove from the beginning [default:0]? ";
    $deb_sec=<STDIN>;
    chomp($deb_sec);
    $deb_sec=0 if ( $deb_sec eq "" );

    pwarn("\t**** WARNING ****\nIn cluster mode we split the movie after it's completly encoded\n") and sleep(5) if ( $last_sec > 600 or $deb_sec > 600 ); 

    open(CONF,">>tmp/V2divx.conf");
    print CONF "#last_sec:$last_sec\n";
    close CONF;

    #*************SOUND SAMPLE**********************
    $as=20;
    get_audio_channel;
    if ( $NOAUDIO != 1 )
    {
        print " Do you want to make Sound samples to find which audio channel is the one you want (y|N)? ";
        $rep=<STDIN>;
        chomp($rep);
        $pcm_swb="";
        my($chkpcm)=0;
        if ( $rep eq "o" ||   $rep eq "O" ||  $rep eq "y" ||  $rep eq "Y" )
        {
            for ($i = 0; $i <= $number_of_ac; $i ++)
            {
                make_sample(" -y $DIVX $DIVX_OPT $VID_OPT -a $i $pcm_swb ", "audio_sample._-a_${i}_", $audiosample_length);
                print "\n To hear this audio sample, please press Enter ->";
                $junk=<STDIN>;
                system("$AVIPLAY audio_sample._-a_${i}_.avi > /dev/null 2>&1 ")==0 or mydie "Problem to run \'$AVIPLAY audio_sample._-a_${i}_.avi\'";
                my($audio_format)=audioformat("-a $i");
                if ($audio_format eq "pcm" && $chkpcm eq 0 )
                {
                    pinfo("$v2d\t Audio channel $i format:\t\t   | $audio_format\n");
                    print " Was the sound completly noisy (y|N)? ";
                    $rep= <STDIN>;
                    chomp($rep);
                    if ( $rep eq "O" or $rep eq "o" or $rep eq "y" or $rep eq "Y")
                    {
                        pinfo("$v2d\t Remake this sample with option:\t   | -d\n");
                        $pcm_swb='-d' ;
                        unlink("audio_sample._-a_${i}_.avi");
                        $i--;
                        $chkpcm=1;
                        next;
                    }
                    $chkpcm=1;
                }
                print " Was it the Audio channel you want (y|N)? ";
                $rep= <STDIN>;
                chomp($rep);
                if ($rep eq "O" or $rep eq "o" or $rep eq "y" or $rep eq "Y")
                {     
                    unlink("audio_sample._-a_${i}_.avi");
                    $as=$i;
                    last;
                } elsif ($i == $number_of_ac )
                {
                    pwarn("\tNo more Audio channels !\n");
                }
                unlink("audio_sample._-a_${i}_.avi");
                $chkpcm=0;
            }
        }
        while ( ! grep (/$as/,@achannels) )
        {
            print " Enter audio stream number to process [default:$audio_channel]? ";
            $as=<STDIN>;
            chomp($as);
            $as = $audio_channel if ( $as eq "" );
            pwarn("$as : is not an available audio channel.\n") if  ( ! grep (/$as/,@achannels) );
        }
        $audio_channel=$as;
        my($audiofmt_ch1)=audioformat("-a $as");
        pinfo("$v2d\t Audio channel $as format:\t\t   | $audiofmt_ch1\n");
        if ($audiofmt_ch1 eq 'pcm' && $chkpcm eq 0 )
        {
            pwarn("$v2d\t As this audio channel is PCM format, it may be completly noisy\n");	
            make_sample(" -y $DIVX $DIVX_OPT $VID_OPT -a $as", "audio_sample._-a_${as}_", $audiosample_length);
            print " Ear this audio sample, please press Enter ->";
            $junk=<STDIN>;
            system("$AVIPLAY audio_sample._-a_${as}_.avi > /dev/null 2>&1 ") ;# or mydie "Problem to run \'$AVIPLAY audio_sample._-a_${as}_.avi\'";
            unlink("audio_sample._-a_${as}_.avi");
            print " Was this sample completly noisy (y|N)? ";
            $rep=<STDIN>;
            chomp($rep);
            if ( $rep eq "O" or $rep eq "o" or $rep eq "y" or $rep eq "Y")
            {
                $pcm_swb="-d";
            }
        }

        $good_audio="-a $audio_channel $pcm_swb";
        if ( $number_of_ac > 0 )
        {
            print " Do you want to have another audio channel in your AVI movie (take care of the Video quality which decrease with 2 audio channels for the same movie size), this audio channel will be encoded at the same bitrate than the first audio channel (y|N)? ";
            $rep=<STDIN>;
            chomp($rep);
            if ( $rep eq "y" || rep eq "O" ||  $rep eq "o" ||  $rep eq "Y" )
            {
                $ac2=100;
                while($ac2>$number_of_ac || $ac2 == $audio_channel )
                {	
                    print " Enter the other audio channel number you want(MAX=$number_of_ac): ";
                    $ac2=<STDIN>;
                }
                chomp($ac2);
                $audiofmt_ch2=audioformat("-a $ac2");
                pinfo("$v2d\t Audio channel $ac2 format:\t\t   | $audiofmt_ch2\n");
                open (CONF,">>tmp/V2divx.conf");
                print CONF "#ac2:$ac2 $pcm_swb\n";
                close(AC2);
            }
        }
        a_bitrate;
    }

    $params = $good_audio;

    #****************CROPPING TOP/BOTTOM ***********************
    findclip;
    print " Clipping Top/Bottom \n You must have the smallest black LetterBox at top/bottom \n (It's better to leave black LetterBox at top/bottom if you intend to have SubTitle)\n";
    print " To see the first sample, please press Enter -->";
    $rep=<STDIN>;
    system("/bin/rm video_s._-j_*.ppm 2> /dev/null ");
    $inc=8;
    while ( $rep ne "O" &&  $rep ne "o" && $rep ne "y" && $rep ne "Y" )
    {
        $sys="transcode -q 0 -M 1 $REV_VID -x $in_video_codec,null -i \"$VOBPATH/$sample\" -j $tb,$lr -y ppm,null -c 10-11 -o video_s._-j_$tb,$lr_";
        print $INFO "$sys\n";
        system ($sys."  > /dev/null");
        $tmp = `/bin/ls -1 video_s._-j_$tb,$lr_*.ppm`;
        @aclip = split /\n/, $tmp;
        foreach $file ( @aclip  ) {
            system ("$XV $file");
        }
        print " (Don't care about colors or upside down please)\n Are Top/Bottom LetterBoxes (-j $RED$tb$NORM,$lr) OK ?(y), to big (b) or to small (s): ";
        $rep= <STDIN>;
        chomp($rep);
        if ($rep eq "O" or $rep eq "o" or $rep eq "y" or $rep eq "Y")
        {	
            system("rm video_s._-j_$tb,$lr_*.ppm" );
            $top_bot=1;
            last;
        } elsif ( $rep eq "S" || $rep eq "s"  )
        {
            system("rm video_s._-j_$tb,$lr_*.ppm");
            $top_bot=0;
            $tb=$tb-$inc;
            if ( $tb < 0 ) {
                $tb = 0;
            }
        } elsif  ( $rep eq "B" || $rep eq "b"  )
        {
            system("rm video_s._-j_$tb,$lr_*.ppm" );
            $top_bot=0;
            $tb=$tb+$inc;
        }
    }


    # ***************** CROPPING LEFT RIGHT **************************
    print " Now Clipping Left/Right \n";
    print " To see the first sample, please press Enter -->";
    $rep=<STDIN>;
    $inc=8;
    while ( $rep ne "O" &&  $rep ne "o" && $rep ne "y" && $rep ne "Y" )
    {
        $sys="transcode -q 0 -M 1 $REV_VID -x $in_video_codec,null -i \"$VOBPATH/$sample\" -j $tb,$lr -y ppm,null -c 10-11 -o video_s._-j_$tb,$lr_";
        print $INFO "$sys\n";
        system ("$sys > /dev/null");
        $tmp = `/bin/ls -1 video_s._-j_$tb,$lr_*.ppm`;
        @aclip = split /\n/, $tmp;
        foreach $file ( @aclip  )
        { 
            system ("$XV $file")
        }
        print " (Don't care about colors or upside down please)\n Are Left/Right LetterBoxes (-j $tb,$RED$lr$NORM) OK ?(y), to big (b) or to small (s): ";
        $rep= <STDIN>;
        chomp($rep);
        if ( $rep eq "O" || $rep eq "o" or $rep eq "y" or $rep eq "Y" )
        {	
            system("rm video_s._-j_$tb,$lr_*.ppm");
            $left_right=1;
            last;
        } elsif ( $rep eq "B" || $rep eq "b"  ) {
            system("rm video_s._-j_$tb,$lr_*.ppm");
            $left_right=0;
            $lr=$lr+$inc;
        } elsif  ( $rep eq "S" || $rep eq "s"  ) {
            system("rm video_s._-j_$tb,$lr_*.ppm");
            $left_right=0;
            $lr=$lr-$inc;
            if ( $lr < 0 ) {
                $lr = 0 ;
            }
        }
    }
    $params = $params." -j $tb,$lr";

    #************************* SUBTITLE ***********************
    $st=20;
    if ( $in_video_magic eq 'mov' )
    {
        $SUBT=`tcprobe -i $VOBPATH/$sample -H 15 2> /dev/null` or mydie "Problem when running \'tcprobe -i $VOBPATH/$sample -H 15 \'";
    } else {
        $SUBT=`tcprobe -i $VOBPATH -H 15 2> /dev/null` or mydie "Problem when running \'tcprobe -i $VOBPATH \'";
    }

    $number_of_st=`cat tmp/probe.rip | grep subtitle | wc -l ` if ( -f "tmp/probe.rip" );
    if ( ($SUBT =~ m,detected \((\d+)\) subtitle,) || ( defined($number_of_st) && $number_of_st != 0))
    {      
        $number_of_st=$1 if ( ! defined($number_of_st));
        pinfo("$v2d\t Number of subtitles detected:\t\t   | $number_of_st\n");
        $number_of_st=$number_of_st-1;
        if ( -f "tmp/probe.rip")
        {
            open(PROBE,"<tmp/probe.rip");
            while(<PROBE>)
            { 
                print $GREEN."$v2d\t Subtitle $1 language:\t\t\t   | $2\n".$NORM if ( $_=~ m, subtitle (\d+)=(.*),)	;
            }
            close(PROBE);
        }
        print " Do you want subtitle (y|N)? ";
        $rep= <STDIN>;
        chomp($rep);
        if ($rep eq "O" or $rep eq "o" or $rep eq "y" or $rep eq "Y")
        {
            while ( $st > $number_of_st )
            {
                print " SubTitle number (MAX=$number_of_st)[default:0]? ";
                $st=<STDIN>;
                chomp($st);
                $st = 0 if ( $st eq "" );
            }
            pinfo("$v2d\t Detected subrip Transcode contrib:\t   | ");
            if ( $SUBRIP eq "OK" && $in_video_magic eq 'vob' )
            {
                print "yes\n".$NORM;
                print " Do you want subtitles to be in the movie Encoded or in a separate File (E|f)? ";
                $rep= <STDIN>;
                chomp($rep);
            } else {	
                print $RED."NO\n".$NORMAL;
            }
            if ($rep eq "F" or $rep eq "f")
            { 
                if ( $deb_sec)
                {   
                    pwarn($v2d."\t Due to synchro we MUST keep begin credits:\n");
                    $deb_sec=0; 
                }
                if ( -f "tmp/probe.rip")
                {
                    open(PROBE,"<tmp/probe.rip");
                    while(<PROBE>)
                    {
                        $stlang=$1 if ( $_=~ m, subtitle 0${st}=<(.*)>,);
                    }
                    close(PROBE);
                }else{
                    print " What is the language of this subtitle ?\n\t1) en\n\t2) fr\n\t3) de\n\t4) es\n";
                    $rep=<STDIN>;
                    SWITCH:
                    {
                        if ( $rep == 2 ) { $stlang = fr ; last SWITCH ;}
                        if ( $rep == 3 ) { $stlang = de ; last SWITCH ;}
                        if ( $rep == 4 ) { $stlang = es ; last SWITCH ;}
                        $stlang = en ; 
                    }
                }
                $sub_title="SRT_${st}_${stlang}";
            } else {
                $sub_title="extsub=$st:$tb:0:1:$EXTSUB,";
            }
            open (CONF,">>tmp/V2divx.conf");
            print CONF "#deb_sec:$deb_sec\n";
            print CONF "#sub_title:$sub_title\n";
            close (CONF);
        }

    }

    zooming;

    #************** ANTIALIASING & DEINTERLACING ******************** 
    interlaced;
    print " Do you want to deinterlace this movie(";
    print "Y|n)? " if ( $INTERLACE eq "yes" );
    print "y|N)? " if ( $INTERLACE eq "no") ;
    $rep= <STDIN>;
    chomp($rep);
    

    if ( $rep eq "O" || $rep eq "o" || $rep eq "y" || $rep eq "Y" || ($INTERLACE eq "yes" && $rep ne 'N' && $rep ne 'n') ) # Bug
    {	
        open (CONF,">>tmp/V2divx.conf");
        if ( $TELECINE )
        {
            $deintl="ivtc,32detect=force_mode=3,decimate," if ( $TELECINE ) ;
            print CONF "#deintl:$deintl\n";
        }else{
            $PP=`transcode -J pp=lb -c 9-11  2>&1 | grep failed`;
            pinfo("$v2d\t Mplayer postproc. enable:\t\t   | ");
            print "YES\n".$NORM if ( $PP eq "" ) ;
            print "NO\n".$NORM if ( $PP ne "" ) ;
            print " To deinterlace, do you want to use:\n";
            print "\tA) The -I 3 transcode option (a|A)\n\tB) The YUVdenoiser (b|B)";
            print "\n\tC) the smart deinter filter (c|C)" ;
            print "\n\tD) the Mplayer pp filter (d|D)" if ( $PP eq "" ) ;
            print " [default:A]?:";
            $rep= <STDIN>;
            chomp($rep);
            if ( ($rep eq "D" || $rep eq "d") && $PP eq "" )
            {
                $deintl="pp=lb,";
                print CONF "#deintl:$deintl\n";
            } elsif  ( $rep eq "B" || $rep eq "b" )
            {
                $deintl="yuvdenoise=sharpen=100:deinterlace=1,";
                print CONF "#deintl:$deintl\n";
            } elsif  ( $rep eq "C" || $rep eq "c" )
            {
                $deintl="smartdeinter=diffmode=2:highq=1:cubic=1,";
                print CONF "#deintl:$deintl\n";
            } else {
                $dintl=" -I 3";
            }
            close (CONF);
        } # END $TELECINE

    }
    print " Does your clip need Antialiasing (slower) (y|N)? ";
    $rep= <STDIN>;
    chomp($rep);

    $aalias=" -C 3" if ( $rep eq "O" || $rep eq "o" || $rep eq "y" || $rep eq "Y" );
    #       Write parameters
    ( $left_right eq 1 && $top_bot eq 1 ) or mydie "Oups Sorry.. I miss some parameters :-(";
    $params = $params.$dintl.$aalias;
    open (CONF,">>tmp/V2divx.conf");
    print CONF "#params:$params # YOU MUST KNOW WHAT YOU DO IN THIS LINE\n";
    close(CONF);

    #    Ask for a Logo
    ask_logo;
    #     Search DVD Title
    if ( ! defined($dvdtitle))
    {
        print " Enter the title of this movie (blank space available): ";
        $dvdtitle=<STDIN>;
        $dvdtitle =~ s/ /_/g;
        chomp($dvdtitle);
        if ( $dvdtitle eq "" ) {
            $dvdtitle="movie";
        }
    }
    open (CONF,">>tmp/V2divx.conf");
    print CONF "#dvdtitle:$dvdtitle # DO NOT MODIFY THIS LINE\n";
    print CONF "#TELECINE:$TELECINE# DO NOT MODIFY THIS LINE\n";
    print CONF "#VFORMAT:$VFORMAT# DO NOT MODIFY THIS LINE\n";
    close(CONF);

}   # END Config 

# *************** RIP A DVD ***********************
sub ripdvd
{ 	
    $VOBPATH= $ARGV[0];
    ( -e $VOBPATH ) or mydie "Directory \"$VOBPATH\" does not exist \n Sorry";
    print " On which device is your DVD [default: /dev/dvd]? " ;
    $dvd=<STDIN>;
    chomp($dvd);
    $dvd="/dev/dvd" if ( $dvd eq "" ); 
    if ( $DVDTITLE ne "" )
    { 
        $dvdtitle=`$DVDTITLE $dvd 2> /dev/null` or die "Problem when running \'dvdtitle $dvd\'";
        chomp($dvdtitle);
    } else {  	
        print " V2divx does'nt find dvdtitle, please enter this DVD Movie Title: ";
        $dvdtitle=<STDIN>;
        $dvdtitle =~ s/ /_/g;
        chomp($dvdtitle);
        $dvdtitle = VT if ( $dvdtitle eq "" );
    }
    print $RED;
    print "******* WARNING *********\n";
    print "All files in $VOBPATH will be deleted !!!\n";
    print "Press Enter to continue or <Ctrl-C> to Abort\n";
    print $NORM;
    $rep=<STDIN>;
    $probe = `tcprobe -i \"$dvd\" 2>&1` or die "Problem when running \'tcprobe -i $dvd\'";
    ($probe =~ m,DVD title \d+/(\d+),) or die "Probing DVD failed! - No DVD?";
    $totalTitles = $1;
    print " titles: total=$totalTitles\n";

    @checkTitles = 1 .. $totalTitles;
    # now probe each title and find longest
    $longestLen   = 0;
    $longestTitle = 0;
    for(@checkTitles) {
        # call tcprobe for info
        $probe = `tcprobe -i \"$dvd\" 2>&1 -T $_` or die "Problem when running \'tcprobe -i $dvd\'";
        # extract title playback time -> titlelen
        ($probe =~ m,title playback time: .* (\d+) sec,) or die "No time found in tcprobe for title $_ !";
        $titleLen[$_] = $1;
        # extract title set (VTS file) -> titleset
        ($probe =~ m,title set (\d+),) or die "No title set found in tcprobe for title $_! ";
        $titleSet[$_] = $1;
        # extract angles
        ($probe =~ m,(\d+) angle\(s\),) or die "No angle found in tcprobe for title $_ !";
        $angles = $1;
        # extract chapters
        ($probe =~ m,(\d+) chapter\(s\),) or die "No chapter found in tcprobe for title $_ !";
        $chapters = $1;

        # calc hour, minute of title len
        $sec  = $titleLen[$_];
        $hour = int($sec / 3600);
        $sec -= $hour * 3600;
        $min  = int($sec / 60);
        $sec -= $min * 60;

        # verbose
        printf("%02d: len=%02d:%02d:%02d titleset=%02d angles=%02d chapters=%02d\n", $_,$hour,$min,$sec,$titleSet[$_],$angles,$chapters);

        #  find largest title
        if($titleLen[$_] > $longestLen) {
            $longestLen   = $titleLen[$_];
            $longestTitle = $_;
        }
    }
    print " The Main Title seems to be the Title No : $longestTitle, OK ? (y/n) :";
    $rep=<STDIN>;
    chomp($rep);
    if ( $rep ne "o" &&  $rep ne "O" && $rep ne "y" && $rep ne "Y" ) 
    { 	
        print "Ups... Enter the Title number please : ";
        $longestTitle=<STDIN>;
        chomp($longestTitle);
    }
    #  Check if this title is multiangle ....
    $probe = `tcprobe -i \"$dvd\" 2>&1 -T $longestTitle` or die "Problem when running \'tcprobe -i $dvd\'";
    ($probe =~ m,(\d+) angle\(s\),) or die "No angle found in tcprobe for title $longestTitle !";
    $angles = $1;
    if ( $angles > 1 )
    { 	
        pwarn("***************** WARNING!!!! *********************\n\t This is a multi angles video stream. \n");
        print " Do you know which angle number you want to rip (y|N)? ";
        $rep=<STDIN>;
        chomp($rep);
        die "OK ... Have a look on your DVD to find which angle you like\n Bye" if ( $rep ne "o" &&  $rep ne "O" && $rep ne "y" && $rep ne "Y" );
        print " OK ... we continue ...\n";
        print " There is $angles which one do you want? ";
        print $NORM;
        $angle=<STDIN>;
        chomp($angle);
    } else {
        $angle=1;
    }
    #  Check if this title is multichapter
    ($probe =~ m,(\d+) chapter\(s\),) or die "No chapter found in tcprobe for title $longestTitle !";
    $chapter=$1;
    if ( $chapter > 1 )
    { 	
        print " Do you want to rip this title chapter by chapter (y|N)? ";
        $rep=<STDIN>;
        chomp($rep);
    }

    system("/bin/rm -rf $VOBPATH/*  2> /dev/null");
    open (TITLE,">$VOBPATH/dvdtitle");
    print TITLE $dvdtitle;
    close(TITLE);
    opendir(VOB,$VOBPATH);
    chdir($VOBPATH) or die "Unable to chdir to $VOBPATH.. please DO NOT USE the ~ character in the /path/to/vob";
    $sys="tcprobe -i $dvd -T $longestTitle >> probe.rip 2>&1 ";
    system ("nice -$nice $sys");
    if ( $rep eq "y" || $rep eq "Y" || $rep eq "o" || $rep eq "0")
    {
        for ( $i=1;$i<=$chapter;$i++)
        {
            $sys="tccat -i $dvd -T $longestTitle,$i,$angle | split -b 1024m - ${dvdtitle}_T${longestTitle}_C${i}_" ;
            print $INFO $sys."\n";
            system("nice -$nice $sys");
        }
    } else {
        $sys="tccat -i $dvd -T $longestTitle,-1,$angle | split -b 1024m - ${dvdtitle}_T${longestTitle}_" ;
        print $INFO $sys."\n";
        system("nice -$nice $sys");
    }
    # Check if $dvdtitle is well in the vob file name AND the vob file is well in the current directory 
    my(@files)=grep {
        /$dvdtitle/ && -f "$_"
    } readdir(VOB);
    closedir(VOB);
    my($i)=0;
    foreach $vob (@files) {
        rename($vob,$vob.".vob");
        $i++;
    }
    open (PROBE,">>probe.rip");
    print PROBE "Number of vob files:$i" ;
    close(PROBE);
    pinfo("$v2d\t Video files are in:\t\t   | $VOBPATH\n");
    print " You may now run V2divx with yours arguments to encode the vob file(s)\n\n";
    exit(0);
} # END ripdvd

sub pinfo
{
    # takes a string a prints a green message:
    print STDOUT $GREEN."@_".$NORM;
}

sub perror
{
    # takes a string and prints a red error message
    print $DEBUG $RED."@_".$NORM;
}

sub pwarn
{
    # takes a string and prints a red warn message
    print STDOUT $RED."@_".$NORM;
}


#********************* MAIN () **************************

if ($ARGV[1] eq "config")
{
    config;
    ask_clust;
}

if ( $RUNCLUST )
{
    if (defined($ARGV[0]))
    {
    # $ARGV[0] is the dir where user is working on the master (NOT the $VOBPATH)
        $wdir=$ARGV[0];
        chdir($wdir) or mydie $wdir." does not exist or isn't a directory";		
        # We are on a cluster node all needed parameters ARE known via -->
        readconf;
        chk_wdir; # is needed to know input video format
        # And now we can aviencode  
        zooming;
        aviencode;
        exit(0);
    } else {
        mydie "Error: Why run V2divx with --runclust option ?\n";
    }
    # We do never come here !
    exit(1);
}

if ( $VERSION ) 
{
    print "V2divx v$release\n";
    exit(0);
}

if ($ARGV[1] eq "rip" )
{ 
    ripdvd;
}	

if ( $TVREC )
{
     my $nvrec=`transcode -V -c 0-1 -x nvrec,null -i /dev/null -y $DIVX,null $DIVX_OPT -o /dev/null  2>&1 | grep -i "Unable to detect NVrec version"`;
    mydie("You want to record TV but it seems that NVrec is'nt install on this system?\n") if ( $nvrec ne "" );
    mydie "There is still a tmp/V2divx.conf , please remove all tmp files\n (or at least tmp/V2divx.conf) before running V2divx /path/to/vob --tv " if ( -e "tmp/V2divx.conf") ;
    $VOBPATH= $ARGV[0];
    mydie "Directory \"$VOBPATH\" does not exist \n Sorry" if ( ! -e $VOBPATH);
    umask(000);
    mkdir ("tmp",01777);
    tv_recorder;
}

if ( $SRTSUBRIP )
{
    print $DEBUG "$0 called with --srtsubrip\n";
    readconf;
    srt_subrip($1,$2) if ( $sub_title =~ m,SRT_(\d+)_(.*),);
    exit(0);
}

if ( 
    ( defined ($ARGV[0]) 
        && $ARGV[0] ne  "continue" 
        && ! defined($ARGV[1]) ) 
    || $HELP == 1
)
{ 
    system (" echo \"$usage\" | less -R ");
    exit(1);
}


if ($ARGV[1] eq "continue" || $ARGV[0] eq "continue" || ! defined($ARGV[0]))
{	
    unlink("tmp/cluster.args");
    # We CONTINUE ....
    get_params;
}  

if ( defined($ARGV[1])  && $ARGV[1] ne "config" && ! $SRTSUBRIP )
{
    pinfo("$v2d\t Quick Mode:\t\t\t\t   | Yes\n");
    mydie "There is still a tmp/V2divx.conf , please remove all tmp files\n before running V2divx /path/to/vob SIZE" if ( -e "tmp/V2divx.conf") ;
    get_params;
}

if (1)
{
    aviencode;	
    pinfo("$v2d\t Renaming tmp/2-${dvdtitle}_0.avi tmp/2-${dvdtitle}_sync.avi\n");
    rename("tmp/2-${dvdtitle}_0.avi","tmp/2-${dvdtitle}_sync.avi");
    twoac;
    finish;
    # We do never come here !
    exit(1);
}
