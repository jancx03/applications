#!/usr/bin/perl -w
# $Revision: 1.4 $
#
# Adds user to ldap server running on ldap://localhost:389
#
# prints LDIF if --ldif is passed
#
use strict;
$|++;    # disable buffer (autoflush)

use Net::LDAP;
use URI;
use Getopt::Long;
Getopt::Long::Configure('bundling');

my $USAGE =
  'adduser-ldap [--uid="username"] <--first="First"> <--last="Lastname"> [--password="passwd"] [--email="mail_id"] <--domain="domain.com"> [--organizational-unit|--ou="People"] [--posix] [--nt] [--uid-number] [--gid=number] [--home-path|--home] [-D|--bind] [-w|--bind-password="ldapsecret"] [-W|--bind-password-file="/etc/adduser-ldap.secret"] [--groups="group1,group2,..."] [--host="ldapserver"] [| ldapadd -x -D "cn=Directory Manager" -W]'
  . "\n\nExample: adduser-ldap --uid=ismith --first=ivan --last=smith --email='ismith\@example.org' --domain=example.org --posix --uid-number=1023 --ldif --home-path=/home/ismith --password=secret123 --ou=People --groups=mygroup |ldapadd -x -D 'cn=Directory Manager' -W\n";

#my $pass_cmd = "slappasswd";
my $pass_scheme = "\{CRYPT\}";    # SSHA, SHA1, MD5, CRYPT

#my $search_cmd = "ldapsearch -x -Z localhost ";

my $min_uid = "2000";
my $max_uid = "65000";

my $HELP;
my $DEBUG;
my $POSIX;
my $NT;
my $OU;
my $LDIF;

my $LDAPADMINCN      = "";      # -D or --bind
my $LDAPSERVER       = "localhost";
my $LDAPPASSWORDFILE = "/etc/adduser-ldap.secret";
my $LDAPPASSWORD     = "";

my %rec = ();

my $first = "";    # first name
my $last  = "";    # last name (surname)
my $uid   = "";    # User ID for login
my $mid   = ""
  ; # User ID for our emails: $first_letter$lastname scheme. or full email: $first_letter$lastname@$domain
my $domain    = "";    # yields dc=domain,dc=com
my $edomain   = "";    # TODO --email-domain. defaults to $domain
my $passwd    = "";    # can pass given encrypted string from command line
my $posix_uid = "";    # --uid-number
my $posix_gid = "";    # --gid-number
my $home      = "";    # --home-path --home
my @groups    = ();    # --groups
my $shell = "/bin/false";    # TODO --shell

# visible domain from the outside word
# TODO set this interactively:
$rec{'webhost'}       = "www";          # name of web server, without the domain
$rec{'office_number'} = "212.123.4567";
$rec{'fax_number'}    = "212.123.4567";
$rec{'mobile_number'} = "212.123.4567";
$rec{'title'}         = "my title";
$rec{'home_number'}   = "212.123.4567";

GetOptions(
    'debug'                      => \$DEBUG,
    'posix'                      => \$POSIX,
    'nt'                         => \$NT,
    'f|first=s'                  => \$first,
    'l|last=s'                   => \$last,
    'u|uid=s'                    => \$uid,
    'e|m|email=s'                => \$mid,
    'd|domain=s'                 => \$domain,
    'o|ou|organizational-unit=s' => \$OU,
    'p|password=s'               => \$passwd,
    'H|home|home-path=s'         => \$home,
    'U|uid-number=i'             => \$posix_uid,
    'G|gid-number=i'             => \$posix_gid,
    'D|bind=s'                   => \$LDAPADMINCN,
    'w|bind-password=s'          => \$LDAPPASSWORD,
    'W|bind-password-file=s'     => \$LDAPPASSWORDFILE,
    'host=s'                     => \$LDAPSERVER,
    'groups=s'                   => sub {
        my $str = $_[1];
        foreach my $_g (split(/[[:blank:],]/, $str))
        {
            next if $_g =~ /^\s*$/;
            push @groups, $_g;
        }
    },
    'ldif'   => \$LDIF,
    'h|help' => \$HELP
          );

if ($HELP) { print $USAGE; exit 0; }

print STDERR ($USAGE) and exit(1)
  if (not $first || not $last || not $domain);

# helpers
sub _debug
{
    my $str = shift;
    print STDERR "DEBUG: $str\n" if ($DEBUG);
}

sub random_password
{
    my $num = shift;
    if ($num !~ /^[[:digit:]]+$/ or $num < 8)
    {
        $num = 8;
    }
    my $count          = $num;
    my @password_chars = ('.', '/', 0 .. 9, 'A' .. 'Z', 'a' .. 'z');
    my $_password      = undef;
    for (1 .. $count)
    {
        $_password .= (@password_chars)[rand(@password_chars)];
    }
    return $_password;
}

sub hash_password
{
    my $str     = shift;
    my $_scheme = shift;
    my $hash    = $str;
    if ($_scheme =~ /crypt/i)
    {

        # generates an MD5 sum salted password with 8 random chars
        $hash = crypt($str, "\$1\$" . random_password(8) . "\$");
    }
    return $hash;
}

sub _create_entry
{
    my ($ldap, $dn, $whatToCreate) = @_;
    if ($DEBUG)
    {
        print "DEBUG: _create_entry\n";
        print("\tdn: ", $dn, "\n");
        foreach (@$whatToCreate)
        {
            print("\t\t", $_, "\n");
        }
        print "\n";
    }
    my $result = $ldap->add($dn, 'attr' => [@$whatToCreate]);
    return $result;
}

# @param whatToModify a hashref like " userPassword => 'foo' "
sub _modify_entry
{
    my ($ldap, $dn, $whatToModify) = @_;
    my $result = $ldap->modify($dn, 'replace' => {%$whatToModify});
    return $result;
}

sub _add_entry
{
    my ($ldap, $dn, $whatToModify) = @_;
    my $result = $ldap->modify($dn, 'add' => {%$whatToModify});
    return $result;
}

sub _get_password
{
    my $file = shift;
    if (-r $file)
    {
        open(PW, "<$file") or die("Could not read file $file. " . $!);
        undef $/;    # slurp mode
        my $content = <PW>;
        $content =~ s/(\r|\n)//g;
        return $content;
    }
    else
    {
        die("Could not read password file $file\n");
    }
}

# end helpers

# set some internal vars:
my @domain_parts = split(/\./, $domain);
$edomain = (not $edomain) ? $domain : $edomain;

# create UID and MID using scheme:
#   (first letter of first name) + (last name)
$uid = ($uid ne "") ? $uid : lc(substr($first, 0, 1) . $last);

if ($mid)
{
    if ($mid !~ /@/)
    {
        $mid .= "\@" . $edomain;
    }
}
else
{
    $mid = lc(substr($first, 0, 1) . $last) . "\@" . $edomain;
}

$home = ($home ne "") ? $home : "/home/$uid";    # --posix only

my $full_name = ucfirst($first) . " " . ucfirst($last);
my $initials = substr($first, 0, 1) . substr($last, 0, 1);

# --posix only
# TODO calculate uid number from previous LDAP user_list
my $uid_number =
  ($posix_uid ne "")
  ? $posix_uid
  : sprintf("%02d", rand(my @ary = ($min_uid .. $max_uid)));
my $gid_number =
  ($posix_gid ne "")
  ? $posix_gid
  : "100";    # TODO get a good GID number from LDAP

$passwd =
  ($passwd ne "")
  ? hash_password($passwd,            $pass_scheme)
  : hash_password(random_password(8), $pass_scheme);

# TODO sanity checks: mid, uid, uidNumber, gidNumber, ...

my $ou = ($OU) ? "ou=$OU, " : "";
my $domain_joined = "";
foreach (@domain_parts)
{
    $domain_joined .= "dc=$_, ";
}
$domain_joined =~ s/, $//;

my $ldif = "
dn: uid=$uid, $ou $domain_joined
objectClass: top
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson";

$ldif .= "
objectClass: posixAccount
objectClass: shadowAccount" if ($POSIX);

# TODO fix the stuff with 1234
$ldif .= "
cn: $full_name
sn: $last
givenName: $first
initials: $initials
title: $rec{'title'}
uid: $uid
mail: $mid
telephoneNumber: $rec{'office_number'}
facsimileTelephoneNumber: $rec{'fax_number'}
homePhone: $rec{'home_number'}
mobile: $rec{'mobile_number'}
roomNumber: 0
carLicense: 1234
departmentNumber: 1234
employeeNumber: 1234
employeeType: full time
preferredLanguage: en
labeledURI: http://people.$edomain/${first}_${last} User Home Page";

$ldif .= "
homeDirectory: $home
gecos: $full_name,101 5th Ave,212.620.6001,646.123.4567,Super User
shadowMin: -1
shadowMax: 99999
shadowWarning: 7
shadowInactive: -1
shadowExpire: -1
uidNumber: $uid_number
gidNumber: $gid_number
userpassword: ${pass_scheme}${passwd}
loginShell: $shell

" if ($POSIX);

if ((@groups + 0))
{
    foreach my $_group (@groups)
    {
        $ldif .= "

dn: cn=$_group,ou=Groups,$domain_joined
changetype: modify
add: uniqueMember
uniqueMember: uid=$uid, $ou $domain_joined
        "
    }
}

# FIXME remove 1 when $ldap auth is done
if ($LDIF)
{
    print STDOUT ($ldif, "\n");
    exit 0;
}

$LDAPADMINCN = ($LDAPADMINCN) ? $LDAPADMINCN : "cn=admin, $domain_joined";

_debug("connecting to $LDAPSERVER as $LDAPADMINCN");

my $ldap = Net::LDAP->new($LDAPSERVER);
my $mesg = $ldap->bind(
    $LDAPADMINCN,

    # --bind-password takes precedence
    'password' => ($LDAPPASSWORD)
    ? $LDAPPASSWORD
    : _get_password($LDAPPASSWORDFILE),
    'version' => '3'
                      );    # if bind() it binds anonymously
my $_dn = "uid=${uid},${ou}${domain_joined}";

my $CODE = 0;               # assume we won't have errors

my $create_ary = [
    objectClass => ["top", "person", "organizationalPerson", "inetorgperson"],
    cn                       => $full_name,
    uid                      => $uid,
    givenName                => $first,
    sn                       => $last,
    mail                     => $mid,
    telephoneNumber          => $rec{'office_number'},
    userPassword             => "${pass_scheme}${passwd}",
    initials                 => $initials,
    title                    => $rec{'title'},
    telephoneNumber          => $rec{'office_number'},
    facsimileTelephoneNumber => $rec{'fax_number'},
    homePhone                => $rec{'home_number'},
    mobile                   => $rec{'mobile_number'},
    roomNumber               => 0,
    carLicense               => 1234,
    departmentNumber         => 1234,
    employeeNumber           => 1234,
    employeeType             => "full time",
    preferredLanguage        => "en",
    labeledURI => "http=>//people.$edomain/${first}_${last} User Home Page"
                 ];

if ($POSIX)
{
    my @_extra_classes = ("shadowAccount", "posixAccount");
    foreach my $obj (@_extra_classes)
    {
        push @{$create_ary->{'objectClass'}}, $obj;
    }

    $create_ary->{'homeDirectory'} = "$home";
    $create_ary->{'gecos'} =
        "$full_name,101 5th Ave,"
      . $rec{'office_number'}
      . ",646.123.4567,Super User";
    $create_ary->{'shadowMin'}      = "-1";
    $create_ary->{'shadowMax'}      = "99999";
    $create_ary->{'shadowWarning'}  = "7";
    $create_ary->{'shadowInactive'} = "-1";
    $create_ary->{'shadowExpire'}   = "-1";
    $create_ary->{'uidNumber'}      = "$uid_number";
    $create_ary->{'gidNumber'}      = "$gid_number";
    $create_ary->{'userpassword'}   = "${pass_scheme}${passwd}";
    $create_ary->{'loginShell'}     = $shell;
}

my $entry_result = _create_entry($ldap, $_dn, $create_ary);

if ($entry_result->code())
{
    print STDERR " Error while creating entry for uid $uid on \$LDAPSERVER\n";

    print STDERR (  ". Server message => code: "
                  . $entry_result->code()
                  . ". name: "
                  . $entry_result->error_name()
                  . ". text: "
                  . $entry_result->error_text());
    $CODE = 1;
    goto EXIT;
}

if (@groups + 0)
{
    my $add_hash = undef;
    foreach my $_group (@groups)
    {
        my $_dn = "cn=$_group,ou=Groups,$domain_joined";
        my $add_hash = ['uniqueMember' => "uid=$uid, $ou $domain_joined"];
    }

    my $entry_result = _add_entry($ldap, $_dn, $add_hash);
    if ($entry_result->code())
    {
        print(" Error while adding uid $uid to group $_dn on $LDAPSERVER: "
              . $entry_result->error_text());
        goto EXIT;
    }
}

EXIT:

$ldap->unbind();    # take down session
$ldap->disconnect();

exit $CODE;
