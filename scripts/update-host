#!/usr/bin/perl -w
# $Revision: 1.8 $
# Luis Mondesi < lemsx1@hotmail.com >
# Last modified: 2005-Jan-20
#
# DESCRIPTION: A simple script to update my settings in $HOME
# USAGE: $0 [--remove|--verbose]
#
# If remove is passed, the FILES will be deleted after downloading them
#
use strict;
$|++;

use Getopt::Long;
Getopt::Long::Configure('bundling');

my $MASTER_HOST = "http://lems1.kiskeyix.org";
my $LOCAL_PATH  = "$ENV{'HOME'}/Shared/software/settings";
my $REMOTE_HOSTS_FILE = "$ENV{'HOME'}/.remote-hosts";
# path to temporary directory
my $TMP="tmp";

# ary of systems to be excluded from updating
# separate by |. i.e.: 127.0.0.1|192.168.1.2|10.1.1.1
my $EXCLUDE= "172.16.1.250|as400";
# files we will be updating
my @FILES=("bashrc.tar.bz2", "vimrc.tar.bz2", "muttrc.tar.bz2", "Applications.tar.bz2");
 
############## NO NEED TO MODIFY THESE #################
my @hosts; # global variable to hold hosts
my $VERBOSE=0;
my $DEBUG=0;
my $REMOVE_FILES=0;
my $MASTER=0; # update current host from $MASTER_HOST

my $VERBOSE_ARGS="";
my $WGET_ARGS="--continue --timestamping";

## GET OPTIONS ##
GetOptions(
    # flags
    'debug'         =>  \$DEBUG,
    'remove'        =>  \$REMOVE_FILES,
    'verbose'       =>  \$VERBOSE,
    'master'        =>  \$MASTER
);
## START SCRIPT ##

if ( $VERBOSE )
{
    $VERBOSE_ARGS="v";
} else {
    $WGET_ARGS="-nv $WGET_ARGS";
}

## main ##
my $j =0;
my $n_files = $#FILES+1;
my $silent = ( ! $VERBOSE ) ? " > /dev/null 2>&1" : "";

# update master and exit
if ( $MASTER )
{
    chdir($LOCAL_PATH) or die ("$LOCAL_PATH $!");
    foreach my $i ( @FILES )
    {
        if ( $MASTER_HOST =~ m/^http:/i && -f "$i" )
        {
            # wget is not too smart when using http
            print STDERR ("Deleting $i\n") if ( $DEBUG );
            unlink($i); # silently delete old copies
        }
        print STDOUT "\n";
        printf STDOUT ("%20s","wGetting $MASTER_HOST/$i ");
        system("wget $WGET_ARGS $MASTER_HOST/$i ".$silent);
        print STDOUT ( $? ) ? " failed": " done";
    }
    chdir("$ENV{'HOME'}");
    foreach my $i ( @FILES )
    {
        $j++;
        print STDOUT "\r";
        printf STDOUT ("%20s","localhost"); # host padded
        printf STDOUT ("|%-".$n_files."s|", "#" x $j); # progress
        my $cmd = "command tar x".$VERBOSE_ARGS."jf '$LOCAL_PATH/$i'";
        system($cmd.$silent);
    }
    print STDOUT "\n";
    exit(0);
}

slurp_hosts($REMOTE_HOSTS_FILE);

#print "\e[H\e[J"; # clear the screen

foreach my $h ( @hosts )
{
    next if ( grep(/$EXCLUDE/,$h) );
    #print "\e[H"; # return the cursor to the normal position

    # we only care about IPs here:
    if ( !$DEBUG && $h =~ /(\d+.\d+.\d+.\d+)/ )
    {
        if ( ! is_alive($h) )
        {
            printf STDOUT ("%20s","$h is dead\n");
            next;
        }
        $j=0;
        # make sure the .backup and $TMP dir exists
        system("ssh $h mkdir -p $TMP .backup ".$silent);
        # make sure this signature file exists:
        system("ssh $h touch .signaturerc ".$silent);
        # copy and unpack files:
        foreach my $i ( @FILES )
        {
            $j++;
            print STDOUT "\r";
            printf STDOUT ("%20s",$h); # host padded
            printf STDOUT ("|%-".$n_files."s|", "#" x $j); # progress
            system("scp $LOCAL_PATH/$i $h:$TMP/ ".$silent); 
            my $cmd = "ssh $h command tar x".$VERBOSE_ARGS."jf '$TMP/$i'";
            system($cmd.$silent);
            if ( $REMOVE_FILES )
            {
                system("ssh $h command rm -f '$TMP/$i' ".$silent);
            }
        }
        print STDOUT "\n";
    } else {
        # debugging 
        print "*** SKIPPED $h\n" if ( $DEBUG );
    }
}
print "\n";

sub slurp_hosts
{
    my $file = shift;
    open(FILE,$file) || die ("Could not open $file: $!\n");
    while (<FILE>)
    {
        chomp($_);
        if ( $_ gt "" && $_ !~ /^\s*#/ )
        {
            push @hosts, split(/\s+/,$_);
        }
    }
}

sub is_alive
{
    my $host = shift;
    if ( $host )
    {
        # send 1 package of 8 bytes to $host and wait 2 seconds before
        # exiting
        my $ret = qx/ping -c 1 -w 2 -s 8 $host/;
    }
    # 0 when good
    # 256 when not good
    print ("*** pinging $host returned $?\n") if ( $DEBUG );
    return ( $? ) ? 0:1; # return the opposite of ping's return output
}
