#!/usr/bin/perl -w
# $Revision: 1.16 $
# Luis Mondesi < lemsx1@hotmail.com >
# Last modified: 2005-Feb-28
#
# DESCRIPTION: A simple script to update my settings in $HOME
# USAGE: $0 [--remove|--verbose]
#
# If remove is passed, the FILES will be deleted after downloading them
#
use strict;
$|++;

use Getopt::Long;
Getopt::Long::Configure('bundling');

my $MASTER_HOST = "http://lems1.kiskeyix.org";
my $LOCAL_PATH  = "$ENV{'HOME'}/Shared/software/settings";
my $REMOTE_HOSTS_FILE = "$ENV{'HOME'}/.remote-hosts";
# path to temporary directory
my $TMP="tmp";

# ary of systems to be excluded from updating
# separate by |. i.e.: 127.0.0.1|192.168.1.2|10.1.1.1
my $EXCLUDE= "172.16.1.250|as400";
# files we will be updating
my @FILES=("bashrc.tar.bz2", "vimrc.tar.bz2", "muttrc.tar.bz2", "Applications.tar.bz2");
 
############## NO NEED TO MODIFY THESE #################
my @hosts; # global variable to hold hosts
my $VERBOSE=0;
my $DEBUG=0;
my $REMOVE_FILES=0;
my $MASTER=0; # update current host from $MASTER_HOST
my $LOCAL=0; # do not get any new copies, use the local files instead
my $RED = "\033[1;31m";
my $NORM = "\033[0;39m";
my $GREEN = "\033[0;32m";
my $VERBOSE_ARGS="";
my $WGET_ARGS="--continue --timestamping";

## GET OPTIONS ##
GetOptions(
    # flags
    'debug'         =>  \$DEBUG,
    'remove'        =>  \$REMOVE_FILES,
    'verbose'       =>  \$VERBOSE,
    'master'        =>  \$MASTER,
    'local'         =>  \$LOCAL
);
## START SCRIPT ##

if ( $VERBOSE )
{
    $VERBOSE_ARGS="v";
} else {
    $WGET_ARGS="-nv $WGET_ARGS";
}

## main ##
my $j =0;
my $n_files = $#FILES+1;
my $silent = ( ! $VERBOSE ) ? " > /dev/null 2>&1" : "";

# update master and exit
if ( $MASTER )
{
    my @failed = (); # array of files that failed
    chdir($LOCAL_PATH) or die ("$LOCAL_PATH $!");
    if ( !$LOCAL )
    {
        # download files from remote (master) host:
        foreach my $i ( @FILES )
        {
            if ( $MASTER_HOST =~ m/^http:/i && -f "$i" )
            {
                # wget is not too smart when using http
                debug("Deleting $i");
                unlink($i); # silently delete old copies
            }
            print STDOUT "\n";
            printf STDOUT ("%20s","Downloading $MASTER_HOST/$i ");
            system("wget $WGET_ARGS $MASTER_HOST/$i ".$silent);
            print STDOUT ( $? ) ? " failed": " done";
        }
    }
    print STDOUT ("\n");
    chdir("$ENV{'HOME'}");
    foreach my $i ( @FILES )
    {
        $j++;
        print STDOUT "\r"; 
        my $cmd = "";
        if ( -x which("bzcat") )
        {
            $cmd = "command bzcat '$LOCAL_PATH/$i' | command tar x".$VERBOSE_ARGS."f - ";
        } else {
            # assume tar can decompress on the fly
            debug("Falling back to tar...");
            $cmd = "command tar x".$VERBOSE_ARGS."jf '$LOCAL_PATH/$i'";
        }

        system($cmd.$silent);
        printf STDOUT ("%20s","localhost"); # host padded
        if ( ! $? ) 
        {
            printf STDOUT ("|%-".$n_files."s|", "#" x $j); # progress
        } else {
            # last tar command failed?
            # TODO Find a way to "remember" which file failed
            printf STDOUT ("|%-".($n_files-($j-1))."s|", "#" x ($j-1)); # progress
            printf STDOUT ("%-".($j-1)."s|", "!" x 1); # progress
            push(@failed,"$i");
        }
    }
    print ("\nlocalhost These files failed: ".join ( " ",@failed )."\n") if ( $#failed > 0 );
    print STDOUT "\n";
    exit(0);
}

slurp_hosts($REMOTE_HOSTS_FILE);

#print "\e[H\e[J"; # clear the screen

foreach my $h ( @hosts )
{
    next if ( grep(/$EXCLUDE/,$h) );
    my @failed = (); # array of failes that failed

    #print "\e[H"; # return the cursor to the normal position

    # we only care about IPs here:
    if ( !$DEBUG && $h =~ /(\d+.\d+.\d+.\d+)/ )
    {
        if ( ! is_alive($h) )
        {
            printf STDOUT ("%20s",$h);
            print STDOUT (" is dead\n");
            next;
        }
        $j=0;
        # make sure the .backup and $TMP dir exists
        system("ssh $h mkdir -p $TMP .backup ".$silent);
        # make sure this signature file exists:
        system("ssh $h touch .signaturerc ".$silent);
        # copy and unpack files:
        foreach my $i ( @FILES )
        {
            $j++;
            print STDOUT "\r";
            printf STDOUT ("%20s",$h); # host padded
            system("scp $LOCAL_PATH/$i $h:$TMP/ ".$silent); 
            my $cmd = "ssh $h command tar x".$VERBOSE_ARGS."jf '$TMP/$i'";
            system($cmd.$silent);
            if ( ! $? ) 
            {
                printf STDOUT ("|%-".$n_files."s|", "#" x $j); # progress
            } else {
                # last tar command failed?
                # TODO Find a way to "remember" which file failed
                printf STDOUT ("|%-".($n_files-($j-1))."s", "#" x ($j-1)); # progress
                printf STDOUT ("%-".($j-1)."s|", "!" x 1); # progress
                push(@failed,"$i");
            }
            if ( $REMOVE_FILES )
            {
                system("ssh $h command rm -f '$TMP/$i' ".$silent);
            }
        } 
        print STDOUT ("\n$h These files failed: ".join ( " ",@failed )."\n") if ( $#failed > 0 );
        print STDOUT "\n";
    } else {
        # debugging 
        debug("*** SKIPPED $h");
    }
}
print "\n";

sub slurp_hosts
{
    my $file = shift;
    open(FILE,$file) || die ("Could not open $file: $!\n");
    while (<FILE>)
    {
        chomp($_);
        if ( $_ gt "" && $_ !~ /^\s*#/ )
        {
            push @hosts, split(/\s+/,$_);
        }
    }
}

sub is_alive
{
    my $host = shift;
    if ( $host )
    {
        # send 1 package of 8 bytes to $host and wait 2 seconds before
        # exiting
        my $ret = qx/ping -c 1 -w 2 -s 8 $host/;
    }
    # 0 when good
    # 256 when not good
    debug ("*** pinging $host returned $?");
    return ( $? ) ? 0:1; # return the opposite of ping's return output
}

sub which
{
    # @param 0 string := binary to find in $ENV{PATH}
    # returns binary path or -1 if not found
    my $binary = shift;
    my $path = "-1"; # holds string to return when found. 
    foreach my $binary_path ( split(/:/,$ENV{"PATH"}) )
    {
        next if ( -x "$path" ); # a quick way out. after finding
        # first binary in $ENV{PATH}
        if ( -x "$binary_path"."/$binary")
        {
            $path = "$binary_path"."/$binary";
        }
    }
    return $path; # -1 means not found
}

sub debug
{
    my $msg = "@_";
    print STDERR ("$RED $msg $NORM\n")  if ( $DEBUG );
}

