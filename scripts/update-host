#!/usr/bin/perl -w
# $Revision: 1.20 $
# Luis Mondesi < lemsx1@hotmail.com >
#
# DESCRIPTION: A simple script to update my settings in $HOME @see --help
# USAGE: $0 --help

use strict;
$|++;

use Getopt::Long;
Getopt::Long::Configure('bundling');
#use POSIX;                  # cwd() ... man POSIX
use File::Spec::Functions  qw/ splitdir catdir catfile /;  # abs2rel() and other dir/filename specific
#use File::Copy;
#use File::Find;     # find();
#use File::Basename; # basename() && dirname()
#use FileHandle;     # for progressbar

############## NO NEED TO MODIFY THESE #################
=pod
=head1 update-remote-hosts.pl

update-remote-hosts.pl - by Luis Mondesi <lemsx1@gmail.com>

=head1 SYNOPSIS

B<update-remote-hosts.pl>  
[-v,--version]
[-h,--help]   
[-D,--debug]
[-r,--remove]
[-V,--verbose]
[-m,--master] 
[-l,--local]  
[--host] 
[--files]  
[--print-files]
[--local-path]
[--hosts-file]
[HOSTNAME]

=head1 DESCRIPTION 

This script updates my user configurations on this computer from a remote host, or distributes them from this host to others in ~/.remote-hosts.

The files from the master host will be downloaded using a URL (wget). And all other downloads will be done via ssh (for hosts in ~/.remote-hosts by default).

The script tries to find if a given host is alive first by using ping.

=head1 EXAMPLES

B<update-remote-hosts.pl>  --master --host URL

updates localhost using files from URL

B<update-remote-hosts.pl> --hosts-file ~/.hosts

updates all hosts found in ~/.hosts. If --hosts-file is omitted, it will upgrade all hosts found in ~/.remote-hosts

B<update-remote-hosts.pl> --hosts-file ~/.hosts --files "bashrc.tar.bz2,vimrc.tar.bz2"

updates only bashrc and vimrc files to all hosts found in ~/.hosts

=head1 BUGS

* --files cannot contain spaces and must be .tar.bz2.

* there is no way to pass $EXCEPTIONS from the command line.

=head1 OPTIONS

=cut

my $PVERSION=0;
my $HELP=0;
my $MASTER_HOST = "http://lems1.kiskeyix.org";
my $LOCAL_PATH  = "$ENV{'HOME'}/Shared/software/settings";
my $REMOTE_HOSTS_FILE = "$ENV{'HOME'}/.remote-hosts";
# path to temporary directory
my $TMP="tmp";
# ary of systems to be excluded from updating
# separate by |. i.e.: 127.0.0.1|192.168.1.2|10.1.1.1
my $EXCLUDE= "172.16.1.250|as400";
# files we will be updating
my @FILES=("bashrc.tar.bz2", "vimrc.tar.bz2", "muttrc.tar.bz2", "Applications.tar.bz2");
 
my %hosts; # global multi-dimensional hash to store hosts' information
my $VERBOSE=0;
my $DEBUG=0;
my $PRINT_FILES=0;
my $REMOVE_FILES=0;
my $MASTER=0; # update current host from $MASTER_HOST
my $LOCAL=0; # do not get any new copies, use the local files instead
my $RED = "\033[1;31m";
my $NORM = "\033[0;39m";
my $GREEN = "\033[0;32m";
my $VERBOSE_ARGS="";
my $WGET_ARGS="--continue --timestamping";
my $HOST=undef;

my $CONF_FILES=undef; # comma separated list

## GET OPTIONS ##
=pod
=over 8

=item -v,--version

Prints version and exits

=item -D,--debug

Enables debug mode

=item -h,--help

Prints this help and exits

=item -r,--remove

Remove all temporary files after updating

=item -V,--verbose

be verbose

=item -m,--master

Update localhost from master. Default is to upgrade all the computers found in ~/.remote-hosts. @see --host

=item -l,--local

Use copies in $LOCAL_PATH instead of remote $MASTER_HOST. @see --local-path

=item --local-path PATH

Sets $LOCAL_PATH to PATH instead of the default $ENV{"HOME"}/Shared/software/settings

=item --host URL

Sets $MASTER_HOST to URL

=item --files FILES

Comma separated list of files to get/upgrade instead of the defaults at @FILES.

=item --host-file FILE

Uses FILE instead of ~/.remote-hosts as our hosts file. This file is in the same format as /etc/hosts.

=item --print-files

Prints a list of files and exits. @see --files

=cut

GetOptions(
    # flags
    'v|version'         =>  \$PVERSION,
    'h|help'            =>  \$HELP,
    'D|debug'           =>  \$DEBUG,
    'r|remove'          =>  \$REMOVE_FILES,
    'V|verbose'         =>  \$VERBOSE,
    'm|master'          =>  \$MASTER,
    'l|local'           =>  \$LOCAL,
    'print-files'       =>  \$PRINT_FILES,
    # strings
    'host=s'            =>  \$MASTER_HOST,
    'files=s'           =>  \$CONF_FILES,
    'local-path=s'      =>  \$LOCAL_PATH,
    'hosts-file=s'      =>  \$REMOTE_HOSTS_FILE
) and $HOST=shift;

## START SCRIPT ##

if ( $HELP ) { 
    use Pod::Text;
    my $parser = Pod::Text->new (sentence => 0, width => 78);
    $parser->parse_from_file(File::Spec->catfile("$0"),
			   \*STDOUT);
    exit 0;
}

if ( $VERBOSE )
{
    $VERBOSE_ARGS="v";
} else {
    $WGET_ARGS="-nv $WGET_ARGS";
}

## main ##

my $j =0;
my $n_files = $#FILES+1;
my $silent = ( ! $VERBOSE ) ? " > /dev/null 2>&1" : "";

if ( defined ($CONF_FILES) )
{
    $CONF_FILES =~ s/[,|\s]+/ /g; # separate by single spaces
    @FILES = split(/\s/,$CONF_FILES);
}

if ( $PRINT_FILES )
{
    print STDOUT (join(",",@FILES),"\n");
    exit 0;
}

# update master and exit
if ( $MASTER )
{
    my @failed = (); # array of files that failed
    
    _mkdir($LOCAL_PATH);

    chdir($LOCAL_PATH) or die ("$LOCAL_PATH $!");
    if ( !$LOCAL )
    {
        # download files from remote (master) host:
        foreach my $i ( @FILES )
        {
            if ( $MASTER_HOST =~ m/^http:/i && -f "$i" )
            {
                # wget is not too smart when using http
                debug("Deleting $i");
                unlink($i); # silently delete old copies
            }
            print STDOUT "\n";
            printf STDOUT ("%20s","Downloading $MASTER_HOST/$i ");
            system("wget $WGET_ARGS $MASTER_HOST/$i ".$silent);
            print STDOUT ( $? ) ? " failed": " done";
        }
    }
    print STDOUT ("\n");
    chdir("$ENV{'HOME'}");
    foreach my $i ( @FILES )
    {
        $j++;
        print STDOUT "\r"; 
        my $cmd = "";
        if ( -x which("bzcat") )
        {
            $cmd = "command bzcat '$LOCAL_PATH/$i' | command tar x".$VERBOSE_ARGS."f - ";
        } else {
            # assume tar can decompress on the fly
            debug("Falling back to tar...");
            $cmd = "command tar x".$VERBOSE_ARGS."jf '$LOCAL_PATH/$i'";
        }

        system($cmd.$silent);
        printf STDOUT ("%20s","localhost"); # host padded
        if ( ! $? ) 
        {
            printf STDOUT ("|%-".$n_files."s|", "#" x $j); # progress
        } else {
            # last tar command failed?
            # TODO Find a way to "remember" which file failed
            printf STDOUT ("|%-".($n_files-($j-1))."s|", "#" x ($j-1)); # progress
            printf STDOUT ("%-".($j-1)."s|", "!" x 1); # progress
            push(@failed,"$i");
        }
    }
    print ("\nlocalhost These files failed: ".join ( " ",@failed )."\n") if ( $#failed > 0 );
    print STDOUT "\n";
    exit(0);
}

# update a single host and exit
if ( $HOST )
{
    debug("Doing single host $HOST");
    print STDERR ("WARNING! This host is in the excluded list\n") 
    if ( grep(/$EXCLUDE/,$HOST) );
    $hosts{$HOST}{alive}=-1; # initialize key
    
    if ( !$DEBUG )
    {
        print update_host($HOST); # prints error if any
    } else {
        debug("*** SKIPPED $HOST");
    }
    exit(0);
}

# do all hosts
slurp_hosts($REMOTE_HOSTS_FILE);

foreach my $h ( keys %hosts )
{
    next if ( grep(/$EXCLUDE/,$h) );
    if ( ! is_alive($h) )
    {
        printf STDOUT ("%20s",$h);
        print STDOUT (" is dead\n");
        next;
    }
    if ( !$DEBUG )
    {
        print update_host($h); # prints error if any
    } else {
        # debugging 
        debug("*** SKIPPED $h");
    }
}

# @desc slurps fields of a hosts file to a global hash: %hosts
sub slurp_hosts
{
    my $file = shift;
    open(FILE,$file) || die ("Could not open $file: $!\n");
    while (<FILE>)
    {
        chomp($_);
        if ( $_ gt "" && $_ !~ /^\s*#/ )
        {
            if ( $_ =~ /(\d+.\d+.\d+.\d+)\s+(\w+)/,$_)
            {
                $hosts{$1}{ip}=$2;
                $hosts{$1}{alive}=-1;
            }
        }
    }
}

# @desc checks whether a given host is alive by pinging it. 
#  pinging to a given host will be cached/saved for us so that we don't 
#  have to test for a given host more than once.
# @arg 1 $host string or ip representing a given host
# @return 1 if true 0 if false
sub is_alive
{
    my $host = shift;
    my $ret = 0; # assume host is not alive

#    no warnings;
    if ( $host && $hosts{$host}{alive} == -1  )
    {
        # send 1 package of 8 bytes to $host and wait 2 seconds before
        # exiting
        my $tmp_str = qx/ping -c 1 -w 2 -s 8 $host/;
        # 0 when good
        # 256 when not good
        debug ("*** pinging $host returned $?");
        # return the opposite of ping's return output
        $ret = ( $? ) ? 0:1;
        $hosts{$host}{alive} = $ret; # save for future reference
    } elsif ( $hosts{$host}{alive} >= 0 ) {
        debug ("*** no need to ping $host [".$hosts{$host}{alive}."]");
        $ret = $hosts{$host}{alive};
    }
    #debug("is_alive returning $ret for $host");
    return $ret;
}

# @desc finds binaries in your $PATH 
sub which
{
    # @param 0 string := binary to find in $ENV{PATH}
    # returns binary path or -1 if not found
    my $binary = shift;
    my $path = "-1"; # holds string to return when found. 
    foreach my $binary_path ( split(/:/,$ENV{"PATH"}) )
    {
        next if ( -x "$path" ); # a quick way out. after finding
        # first binary in $ENV{PATH}
        if ( -x "$binary_path"."/$binary")
        {
            $path = "$binary_path"."/$binary";
        }
    }
    return $path; # -1 means not found
}

# @desc prints colored messages
sub debug
{
    my $msg = "@_";
    print STDERR ("$RED $msg $NORM\n")  if ( $DEBUG );
}

# @desc do all needed steps to update a given host
# @return error string if any errors were found
sub update_host
{
    my $h = shift;
    my $j=0;
    my @failed = (); # array of failes that failed

    # sanity check. make sure host is alive:
    return "ERROR: host $h is dead\n" if ( ! is_alive($h) );

    # make sure the .backup and $TMP dir exists
    system("ssh $h mkdir -p $TMP .backup ".$silent);
    # make sure this signature file exists:
    system("ssh $h touch .signaturerc ".$silent);
    # copy and unpack files:
    foreach my $i ( @FILES )
    {
        next if ( ! -f "$LOCAL_PATH/$i" );
        $j++;
        print STDOUT "\r";
        printf STDOUT ("%20s",$h); # host padded
        system("scp $LOCAL_PATH/$i $h:$TMP/ ".$silent); 
        my $cmd = "ssh $h command tar x".$VERBOSE_ARGS."jf '$TMP/$i'";
        system($cmd.$silent);
        if ( ! $? ) 
        {
            printf STDOUT ("|%-".$n_files."s|", "#" x $j); # progress
        } else {
            # last tar command failed?
            printf STDOUT ("|%-".($n_files-($j-1))."s", "#" x ($j-1)); # progress
            printf STDOUT ("%-".($j-1)."s|", "!" x 1); # progress
            push(@failed,"$i");
        }
        if ( $REMOVE_FILES )
        {
            system("ssh $h command rm -f '$TMP/$i' ".$silent);
        }
    } 
    print STDOUT ("\n$h These files failed: ".join ( " ",@failed )."\n") if ( $#failed > 0 );
    print STDOUT "\n";
    # no errors:
    return "";
}

# @desc implements `mkdir -p`
sub _mkdir
{
    my $path = shift;
    my @dirs = splitdir($path);
    my $last = "";
    my $flag=1;
    foreach (@dirs)
    {
        next if ( $_ =~ m/^\s*$/ );
        $last = ( $flag > 1 ) ? catdir($last,$_) : $_ ;
        mkdir ($last) if ( ! -d $last);
        $flag++;
    }
    return $flag; # number of directories created
}

