#!/usr/bin/env ruby
# == Synopsis
#
# sqlgrep: use this to grep process IDs for a given set of queries
#
# == Usage
#
# sqlgrep [OPTIONS] <--host|-h HOST> <REGEX>
# sqlgrep [OPTIONS] <--host|-h HOST> <--print-columns|-C>
#
# -c, --column OPEATION:
#    Perform operation on each item matched by REGEX
#
#    e.g.:
#    - matching lines whose time is greater than N:
#      sqlgrep ... --column 'Time > N'
#    - matching lines which time is less than or equal to N:
#      sqlgrep ... --column 'Time <= N'
#
#    Operations can be one of:
#    ==
#    <=
#    >=
#    <
#    >
#    !=
#    See --print-columns to know what you can match against
#
# -C, --print-columns:
#    Prints column headers from remote host's 'show full processlist'
#
# -D, --debug
#    Shows debugging information
#
# -f, --full
#    Prints full lines, not just the PIDs
#
# -H, --help
#    Shows this help and exits
#
# -h, --host HOST:
#    MySQL host to connect
#
# REGEX: regular expression to match
# BUGS:
# * when matching columns with --column, you cannot use spaces on value to match:
#   sqlgrep ... --column 'User != system user' # this fails

# TODO:
# - allow sorting by columns (Time) and grepping for Time > N
#
=begin
$Revision: 0.1 $
$Date: 2010-01-16 10:33 EST $
Luis Mondesi <lemsx1@gmail.com>

DESCRIPTION: use this to grep process IDs for a given set of queries
USAGE: sqlgrep <-h HOST> <regex>
LICENSE: GPL
=end



require 'getoptlong'
require 'rdoc/usage'

opts = GetoptLong.new(
    [ '--help', '--usage', '-H', GetoptLong::NO_ARGUMENT ],
    [ '--host', '-h', GetoptLong::REQUIRED_ARGUMENT ],
    [ '--column', '-c', GetoptLong::REQUIRED_ARGUMENT ],
    [ '--print-columns', '-C', GetoptLong::NO_ARGUMENT ],
    [ '--debug', '-D', GetoptLong::NO_ARGUMENT ],
    [ '--full', '-f', GetoptLong::NO_ARGUMENT ]
)

host = nil
column = nil
printcolumns=false
debug=false
full=false

opts.each do |opt, arg|
   case opt
   when '--help','--usage'
      RDoc::usage
   when '--host'
       host = arg.to_s
   when '--column'
       column = arg.to_s
   when '--print-columns'
       printcolumns=true
   when '--debug'
       debug=true
   when '--full'
       full=true
   end
end
regex = ARGV.shift

# we don't need REGEX to print columns
if printcolumns and host
else
    if not host or not regex
        RDoc::usage 1
        exit 1 # never reaches here
    end
end

# helpers
def convert(field,spec)
    if spec == "d"
        field.to_i
    else
        field.to_s
    end
end

# show matching PIDs
_sql = `mysql -h #{host} -e 'show full processlist' mysql`.split(/\n/)

# TODO rescue EPIPE (broken pipe)

# if we are looking for a specific column in addition to regex:
if column or printcolumns
    # get column list
    columns = _sql.first.chomp.split(/\s+/)
    c_keys = {}
    i=0
    puts "Supported columns are:" if printcolumns
    columns.each do |k|
        puts k if printcolumns
        c_keys[k.downcase] = i
        i += 1
    end
    exit 0 if printcolumns

    if debug
        puts "SQL column key/val mapping:"
        c_keys.each do |key,val|
            puts "#{key} => #{val}"
        end
    end

    # split requested --column so we can do the correct operation
    # TODO can this do with eval() or so?
    _keys = column.split(/\s+/)
    c_name = _keys[0].strip.downcase
    c_operation = _keys[1].strip.downcase
    c_value = _keys[2].strip.downcase 
    
    c_value_spec = "s" # assume we are matching strings
    c_value_spec = "d" if c_value =~ /^[[:digit:]]+$/

    puts "column name #{c_name}; operation #{c_operation}; value #{c_value}" if debug

    raise "--column '#{column}' could not be parsed" if not c_name or not c_operation or not c_value

    # print PIDs
    _sql.each do |l|
        l_ary = l.split(/\s+/)

	this_value = l_ary[c_keys[c_name]].downcase

        if debug
            puts "MATCHING: #{regex} and #{this_value} #{c_operation} #{c_value} on: #{l}"
        end

        if l =~ /#{regex}/
            case c_operation
            when /^>=$/
                if convert(this_value,c_value_spec) >= convert(c_value,c_value_spec)
                    print "*** MATCHED: " if debug
                    puts l_ary.first
                end
            when /^<=$/
                if convert(this_value,c_value_spec) <= convert(c_value,c_value_spec)
                    print "*** MATCHED: " if debug
                    puts l_ary.first
                end
            when /^===?$/
                if convert(this_value,c_value_spec) == convert(c_value,c_value_spec)
                    print "*** MATCHED: " if debug
                    puts l_ary.first
                end
            when /^<$/
                if convert(this_value,c_value_spec) < convert(c_value,c_value_spec)
                    print "*** MATCHED: " if debug
                    puts l_ary.first
                end
            when /^>$/
                if convert(this_value,c_value_spec) > convert(c_value.to_i,c_value_spec)
                    print "*** MATCHED: " if debug
                    puts l_ary.first
                end
            when /^!=$/
                if convert(this_value,c_value_spec) != convert(c_value,c_value_spec)
                    print "*** MATCHED: " if debug
                    puts l_ary.first
                end
            end
        end
    end
else
    _sql.grep(/#{regex}/) { |l|
        if full
            puts l
        else
            puts l.gsub(/^([[:digit:]]+).*/,'\1')
        end
    }
end
